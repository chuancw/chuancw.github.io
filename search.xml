<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是接口幂等性</title>
      <link href="/2021/10/17/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2021/10/17/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是幂等性？一次和多次请求某一个资源，对资源本身所产生的的影响均与一次执行的影响相同。</p><p>幂等性是系统服务对外的一种承诺，承诺只要调用接口成功了，多次调用对系统的影响是<font color=orange>一致</font>的。</p><h2 id="幂等性与重复提交比较"><a href="#幂等性与重复提交比较" class="headerlink" title="幂等性与重复提交比较"></a>幂等性与重复提交比较</h2><p><strong>幂等性</strong> 更多使用的情况是第一次请求知道结果，但是由于网络抖动或连接超时等情况未进行正常返回，在这种情况下系统自动再次发起请求，其目的是确认第一次是否请求完成。</p><p><strong>重复提交</strong> 更多使用的情况是第一次请求成功或请求结果暂未返回的情况下，人为的进行多次操作。</p><h2 id="SQL-语句幂等性"><a href="#SQL-语句幂等性" class="headerlink" title="SQL 语句幂等性"></a>SQL 语句幂等性</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行多少次都不会对资源造成影响，查询具有天然的幂等性。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次状态都是一致的，这种场景是幂等操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> score <span class="operator">=</span> score<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>每次执行的结果都会发生变化，这种场景不是幂等操作。</p><p>根据具体场景看能否写成这样的 <font color=orange>SQL</font> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> score <span class="operator">=</span> score<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> score <span class="operator">=</span> <span class="number">59</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次分数都是一致的，这种场景是幂等操作。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次数据都是一致的，这种场景是幂等操作。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`name`, `status`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;tom&#x27;</span>, <span class="number">1</span>, <span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>每次执行的结果都会发生变化，这种场景不是幂等操作。</p><p>根据具体场景看能否为 <font color=orange>name</font> 创建一个唯一索引，或执行类型这样的 <font color=orange>SQL</font> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ... <span class="keyword">values</span> ... <span class="keyword">ON</span> DUPLICATE KEY UPDATE ...</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注意，要使用这条语句，前提条件是这个表必须有一个唯一索引或主键。</span><br></pre></td></tr></table></figure><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>下游系统提供相应查询接口。</p><p>上游系统在 <font color=orange>timeout</font> 后，首先去查询一下，如果查到了，就表明已经做了，成功了就不用做了，失败了就走失败流程。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>将这个查询操作交给下游系统，上游系统只管重试，下游系统保证一次和多次的请求产生的影响是一样的。这时我们就说下游系统提供的接口支持幂等性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>幂等性关注的是多次请求是否对资源产生了副作用，而不是关注的结果。<font color=orange>SELECT</font> 语句有可能每次查询的数据不一致，但是它是幂等性的。</p><p>关于 实现方案 -&gt; 方案二 的具体实现方案，根据业务的实际情况考虑合适的解决方案，比如：通过 <font color=orange>SQL</font> 语句就可以实现幂等，就没必要引入 <font color=orange>全局唯一ID</font> 的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 设计规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈国产数据库在金融界的应用-概念篇</title>
      <link href="/2021/10/10/%E6%B5%85%E8%B0%88%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E9%87%91%E8%9E%8D%E7%95%8C%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%80)/"/>
      <url>/2021/10/10/%E6%B5%85%E8%B0%88%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E9%87%91%E8%9E%8D%E7%95%8C%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>移动互联网发展至今，移动支付占据了90%以上的交易量，传统的金融IT架构面临着海量的高并发响应、处理速度以及安全性的挑战。<br>金融行业的数据库市场，尤其是银行的核心交易系统，一直是 <font color=orange>Oracle、DB2</font> 这类美国传统商业数据库的天下，从银行系统的角度来看，所承担的业务量将是海量式的增长，同时也不可避免带来金融行业数据安全、业务安全方面的风险，传统数据库显然不满足需求了。</p><h2 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h2><p>随着国家有关部门近年来陆续出台相关政策指导文件，推动探索安全可控的金融科技产品，加强银行业信息安全建设，由新型分布式数据库替代传统集中式架构，成为金融级数据库市场的主流趋势。<br>央行19年发布《金融科技(FinTech)发展规划(2019-2021年)》也强调，加强分布式数据库研发应用，为分布式数据库在金融领域的全面应用探明路径。国内众多金融政企机构纷纷开始探索改造原有IT系统，对国产化数据库的需求日益强烈。</p><h2 id="云时代"><a href="#云时代" class="headerlink" title="云时代"></a>云时代</h2><p>在数字经济时代的今天，各行各业都在加速<mark class="hl-label red">上云</mark> ，金融业也行驶在数字化转型的浪潮中。在其背后，数据库承载着金融机构的核心数据，是金融科技业务创新的基础和底座，阿里云、腾讯云、华为云三家中国云计算厂商巨头纷纷推出了自己的国产云数据库产品。</p><h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><h3 id="1、TBase"><a href="#1、TBase" class="headerlink" title="1、TBase"></a>1、TBase</h3><p>分布式HTAP数据库 <font color=orange>TBase（TencentDB for TBase）</font>是腾讯自主研发的分布式数据库系统，集高扩展性、高SQL兼容度、完整的分布式事务支持、多级容灾能力以及多维度资源隔离等能力于一身。TBase 强大的安全和容灾能力，已经成功应用在金融、政府、电信、医疗等行业的核心业务系统。同时，TBase 采用无共享的集群架构，为用户提供容灾、备份、恢复、监控、安全、审计等全套解决方案，适用于GB～PB级的海量 HTAP 场景</p><mark class="hl-label red">TBase</mark> 已经覆盖多个行业的标杆用户，其中对内支持了微信广告、微信支付、腾讯地图以及腾讯游戏等海量数据业务，一笔交易毫秒内即可完成，支撑了微信支付50倍的交易增长<p><img src="https://user-images.githubusercontent.com/37777293/136667363-b81ed98b-a31c-43ba-b187-17d99b941a41.png" alt="TBase"></p><h3 id="2、TDSQL"><a href="#2、TDSQL" class="headerlink" title="2、TDSQL"></a>2、TDSQL</h3><p>分布式数据库<font color=orange>TDSQL（Tencent Distributed SQL）</font>是腾讯打造的一款分布式数据库产品，具备强一致高可用、全球部署架构、分布式水平扩展、高性能、企业级安全等特性，同时提供智能 DBA、自动化运营、监控告警等配套设施，为客户提供完整的分布式数据库解决方案。<br>目前 TDSQL 已经为超过<mark class="hl-label red">600+</mark> 的政企和金融机构提供数据库的公有云及私有云服务，客户覆盖银行、保险、证券、互联网金融、计费、第三方支付、物联网、互联网+、政务等领域。TDSQL 亦凭借其高质量的产品及服务，获得了多项国际和国家认证，得到了客户及行业的一致认可<br><img src="https://user-images.githubusercontent.com/37777293/136667439-a07a62f6-f1c2-4611-9796-3d957a937f8f.png" alt="TDSQL"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 金融 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在最前面的话</title>
      <link href="/2021/10/05/hello-world/"/>
      <url>/2021/10/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome! 这是我的第一篇博客<br>以前的技术博客都保存在公司内网中，外网无法浏览，因此搭建了该网站用来记录和分享<mark class="hl-label blue">技术</mark> 上的点点滴滴</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>及时总结和分享<br>包括但不限于以下内容：</p><blockquote><ul><li>技术总结</li><li>行业思考</li><li>刷题笔记</li><li>职场经验</li></ul></blockquote><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>后续会将本地的笔记和记录整理成博客文章发布</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>都说男怕入错行，哈哈哈，其实那会更想当一个数学老师的，没错，以前可喜欢站在黑板面前讲题，没想到现在是一个名副其实的”键盘侠“，好想再摸一次粉笔哈哈哈哈</p><p>在大学时，也算是比较努力，拿了个ACM区域赛银牌，至于亚洲赛嘛，大神太多我太菜了，随后在百度、今日头条实习，做搜索和推荐相关的开发</p><p>毕业啦，华为给的offer挺香的，留在了<mark class="hl-label blue">西安</mark> ，从事5G相关软件开发</p><p>今年跳槽到了腾讯，从事云计算相关研发</p><p>wuhu，2021年经历了很多很多，总结起来就是<mark class="hl-label orange">酸甜苦辣，后劲十足</mark> </p><p>未来，<mark class="hl-label orange">努力努力再努力！</mark> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何减少代码里的if/else</title>
      <link href="/2021/10/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/"/>
      <url>/2021/10/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>if/else是高级编程语言中最基础的功能，虽然 if/else 是必须的，但滥用 if/else，特别是各种大量的if/else嵌套，会对代码的可读性、可维护性造成很大伤害，对于阅读代码的人来说就是一场灾难。</p><p>本系列博客的目的不是消除if/else,而是如何“写好”if/else</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h2><p>根据if/else的使用方式和场景，大概有如下解决方法</p><blockquote><ul><li>多态</li><li>表驱动</li><li>职责链模式</li><li>卫语句</li><li>Optional</li><li>调整判断逻辑，抽取方法，逻辑优化</li></ul></blockquote><p>本篇博客我介绍的是<strong>表驱动</strong>，后续博客会介绍其他案例<br>首先来看下最简单的if…else if…场景，也是经常可以在代码中看到的案例</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>有如下业务代码demo，根据type值，判断然后返回设备的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑表达模式固定的 if…else</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着时间的积累和项目的迭代，可能会增加越来越多的类型，那么后人会继续增加if/else分支，代码中存在的分支判断就会越来越多，当分支数量实在是多的难以维护的时候，我们就要考虑下，有办法能让这些代码变得更优雅吗？</p><p>可能有的人会说用switch/case来重构代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，换成switch/case也是一样，后续也要维护大量case分支，特别是当同样的逻辑判断出现在多个地方的时候，代码的可读性和维护难易程度将变得非常的糟糕。每次修改时，你必须找到所有有逻辑分支的地方，并修改它们</p><p>下面，我就来介绍一种针对这种if/else判断的最简单的重构方式，那就是使用<strong>表驱动</strong></p><h2 id="4-表驱动重构代码"><a href="#4-表驱动重构代码" class="headerlink" title="4. 表驱动重构代码"></a>4. 表驱动重构代码</h2><p>表驱动方法（Table-Driven Methods），《代码大全》对此进行了详细地讲解。</p><blockquote><p>表驱动法是一种编程模式（Scheme），从表里面查找信息而不使用逻辑语句（if 和case） 它的好处是消除代码里面到处出现的if、else、switch语句，让凌乱代码变得简明和清晰。<br>对简单情况而言，表驱动方法可能仅仅使逻辑语句更容易和直白，但随着逻辑的越来越复杂，表驱动法就愈发有吸引力。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer, String&gt; deviceType2NameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    deviceType2NameMap.put(<span class="number">1</span>, <span class="string">&quot;ONT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">2</span>, <span class="string">&quot;OLT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">3</span>, <span class="string">&quot;ONU&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">4</span>, <span class="string">&quot;MXU&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static方式可以在类初始化时就加载，当然，如果不想写成static，也可以自行加载</p></blockquote><p>那么，查询的时候，直接get就可以了，而且不需要对key值进行额外的判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String deviceName = deviceType2NameMap.get(type);</span><br></pre></td></tr></table></figure><p>当然，还有一种逻辑固定的if/else也很常见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;run&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doRun(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;fly&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doFly(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sleep&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doSleep(param);</span><br><span class="line">&#125; <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>这里分支后的执行过程换成了函数，不同的行为执行不同的函数<br>转换为<strong>表驱动</strong>方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假定上述的param类型为int</span></span><br><span class="line">Map&lt;String, Consumer&lt;Integer&gt;&gt; actionMappings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">initActionMap()&#123;</span><br><span class="line"><span class="comment">// 使用方法引用替换Lambda表达式</span></span><br><span class="line">    <span class="comment">// Test::doRun等价于param -&gt; doRun(param)</span></span><br><span class="line">actionMappings.put(<span class="string">&quot;run&quot;</span>, Test::doRun);</span><br><span class="line">actionMappings.put(<span class="string">&quot;fly&quot;</span>, Test::doFly);</span><br><span class="line">actionMappings.put(<span class="string">&quot;sleep&quot;</span>, Test::doSleep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doRun(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doFly(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doSleep(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionMappings.get(<span class="string">&quot;run&quot;</span>).accept(param);</span><br></pre></td></tr></table></figure><p>可能有人不清楚<strong>Consumer</strong>是个什么，为什么最后又执行了<strong>accept</strong>方法<br>这里简单说下</p><blockquote><ul><li>Consumer&lt;T&gt;是Java8以后提供的函数式接口</li><li>T：入参类型；没有出参</li><li>调用方法：void accept(T t);</li><li>因为没有出参，常用于打印、发送短信等<strong>消费动作</strong></li></ul></blockquote><p>由此可见，表驱动的优势</p><blockquote><ul><li>数据逻辑分离，保证在修改数据时，不会对逻辑产生影响。</li><li>单元测试时可以注入表格，只要数据可以转换成表，我们可以输入任意形式的数据。</li><li>逻辑固定写死在程序中，因为修改逻辑成本高，数据则是灵活变换的，因为修改数据成本低。</li><li>保证多人开发时代码的稳健性，简单的逻辑易于读懂易于维护，并且多人使用时，只用修改数据段即可，而数据本身不需要再测试。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if </tag>
            
            <tag> 优化 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

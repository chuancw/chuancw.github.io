<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stolon-sentinel的Leader选举过程</title>
      <link href="/2022/04/06/Stolon-Sentinel%E7%9A%84Leader%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/04/06/Stolon-Sentinel%E7%9A%84Leader%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="选举原理"><a href="#选举原理" class="headerlink" title="选举原理"></a>选举原理</h2><p>通过阅读etcd提供的Campaign方法，发现选举过程基于了Etcd的几个特性，就可以完成自动选主：</p><ul><li>MVCC：key存在版本属性，没被创建时版本号为0</li><li>CAS操作：结合MVCC，可以实现竞选逻辑，if(version == 0) set(key,value),通过原子操作，确保只有一台机器能set成功；</li><li><strong>Lease租约</strong>：可以对key绑定一个租约，租约到期时没预约，这个key就会被回收；</li><li>Watch监听：监听key的变化事件，如果key被删除，则重新发起竞选。</li></ul><p>&emsp;</p><h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><p>在Sentinel选主时，核心代码逻辑如下：</p><p>首先定义一个了选举接口，可以针对不同的场景实现（在这里只介绍使用etcd方式进行<code>leadership</code>）</p><p><img src="https://user-images.githubusercontent.com/19164993/219949828-964d6a16-4268-463e-89f9-5367455dbc1e.jpg" alt="interface"></p><ul><li><p>RunForEletion方法：进行Leader选举</p></li><li><p>Leader方法：返回Leader节点value值</p></li><li><p>Stop方法：停止处理</p></li></ul><p>&emsp;</p><p>Sentinel结构体定义如下：</p><p><img src="https://user-images.githubusercontent.com/19164993/219949826-f84fdad6-bdf3-4121-8bc2-f659edd64a96.jpg" alt="sentinel"></p><ul><li>election：选举接口</li><li>leader：bool类型，标识当前sentinel节点是否为leader</li><li>leadershipCount：leader任期，每次竞选成功后会+1</li></ul><p>&emsp;</p><p>当Sentinel启动时，首先会启动一个goroutine进行Leader选举</p><p><img src="https://user-images.githubusercontent.com/19164993/219949821-332336ea-f0f7-4867-9179-2804f7efe3d7.jpg" alt="leadership"></p><p>&emsp;</p><p>进入electionLoop方法查看具体选举过程</p><p><img src="https://user-images.githubusercontent.com/19164993/219949830-3c7ac9b8-2386-4cf9-9835-6fb0d1bb9014.jpg" alt="hexin"></p><p>可以看到，调用RunForElection方法去竞争Leader，成为Leader的Sentinel将leader和leadershipCount字段更新</p><p>&emsp;</p><p>进入RunForElection方法，看一下具体实现：</p><p><img src="https://user-images.githubusercontent.com/19164993/219949832-411363e7-6a98-4a49-b48e-6c93691f35c4.jpg" alt="etcds"></p><p>&emsp;</p><p>继续看campaign方法：</p><p><img src="https://user-images.githubusercontent.com/19164993/219949833-25d99ef5-3109-4c6a-8755-8481b45963eb.jpg" alt="campaign"></p><p>&emsp;</p><p>加上注释后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 etcdv3 实现的分布式选举功能</span></span><br><span class="line">func (e *etcdv3Election) campaign() &#123;</span><br><span class="line"><span class="comment">// 在函数退出时关闭已声明的通道 e.electedCh 和 e.errCh</span></span><br><span class="line"><span class="function">defer <span class="title">close</span><span class="params">(e.electedCh)</span></span></span><br><span class="line"><span class="function">defer <span class="title">close</span><span class="params">(e.errCh)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">for</span> </span>&#123;</span><br><span class="line"><span class="comment">// 向通道 e.electedCh 发送 false，表示当前节点未当选</span></span><br><span class="line">e.electedCh &lt;- <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的会话，会话的 TTL 设置为 e.ttl 所表示的秒数，同时使用 e.ctx 作为上下文</span></span><br><span class="line">s, err := concurrency.NewSession(e.c, concurrency.WithTTL(<span class="keyword">int</span>(e.ttl.Seconds())), concurrency.WithContext(e.ctx))</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="comment">// 如果发生错误，则向通道 e.errCh 发送错误，并从该方法返回</span></span><br><span class="line">e.errCh &lt;- err</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的选举对象 etcdElection，该对象使用已创建的会话 s，并在 etcd 中的指定路径 e.path 下执行选举</span></span><br><span class="line">etcdElection := concurrency.NewElection(s, e.path)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选举该节点作为候选人，如果出现错误，则向通道 e.errCh 发送错误，并从该方法返回</span></span><br><span class="line"><span class="keyword">if</span> err = etcdElection.Campaign(e.ctx, e.candidateUID); err != nil &#123;</span><br><span class="line">e.errCh &lt;- err</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向通道 e.electedCh 发送 true，表示该节点已被选中</span></span><br><span class="line">e.electedCh &lt;- <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 select 语句等待上下文 e.ctx 完成或者会话 s 结束，如果会话 s 结束，则向通道 e.electedCh 发送 false，表示该节点未被选中</span></span><br><span class="line">select &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-e.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-s.Done():</span><br><span class="line">e.electedCh &lt;- <span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;</p><p>Campaign方法是etcd提供的leadership核心方法，进去看下具体是怎么实现的(代码太多了就不贴图片了….)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Campaign puts a value as eligible for the election on the prefix</span></span><br><span class="line"><span class="comment">// key.</span></span><br><span class="line"><span class="comment">// Multiple sessions can participate in the election for the</span></span><br><span class="line"><span class="comment">// same prefix, but only one can be the leader at a time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the context is &#x27;context.TODO()/context.Background()&#x27;, the Campaign</span></span><br><span class="line"><span class="comment">// will continue to be blocked for other keys to be deleted, unless server</span></span><br><span class="line"><span class="comment">// returns a non-recoverable error (e.g. ErrCompacted).</span></span><br><span class="line"><span class="comment">// Otherwise, until the context is not cancelled or timed-out, Campaign will</span></span><br><span class="line"><span class="comment">// continue to be blocked until it becomes the leader.</span></span><br><span class="line">func (e *Election) Campaign(ctx context.Context, val string) error &#123;</span><br><span class="line">s := e.session</span><br><span class="line">client := e.session.Client()</span><br><span class="line"></span><br><span class="line">k := fmt.Sprintf(<span class="string">&quot;%s%x&quot;</span>, e.keyPrefix, s.Lease())</span><br><span class="line">txn := client.Txn(ctx).If(v3.Compare(v3.CreateRevision(k), <span class="string">&quot;=&quot;</span>, <span class="number">0</span>))</span><br><span class="line">txn = txn.Then(v3.OpPut(k, val, v3.WithLease(s.Lease())))</span><br><span class="line">txn = txn.Else(v3.OpGet(k))</span><br><span class="line">resp, err := txn.Commit()</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">e.leaderKey, e.leaderRev, e.leaderSession = k, resp.Header.Revision, s</span><br><span class="line"><span class="keyword">if</span> !resp.Succeeded &#123;</span><br><span class="line">kv := resp.Responses[<span class="number">0</span>].GetResponseRange().Kvs[<span class="number">0</span>]</span><br><span class="line">e.leaderRev = kv.<span class="function">CreateRevision</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">string</span><span class="params">(kv.Value)</span> !</span>= val &#123;</span><br><span class="line"><span class="keyword">if</span> err = e.Proclaim(ctx, val); err != nil &#123;</span><br><span class="line">e.Resign(ctx)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = waitDeletes(ctx, client, e.keyPrefix, e.leaderRev-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line"><span class="comment">// clean up in case of context cancel</span></span><br><span class="line">select &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">e.Resign(client.Ctx())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">e.leaderSession = nil</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">e.hdr = resp.Header</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先创建一个 key，然后用事务来进行竞选操作。如果当前 key 的 revision 是 0，表示该 key 没有被其他会话占用，那么就将当前 session 设置为 leader，并将 val 写入该 key 的 value。如果该 key 的 revision 不是 0，那么就从 etcd 中获取该 key 的 value 和 revision，判断它是否是当前 session 的 leader。如果是，则继续保持当前 session 为 leader；否则，使用 Proclaim 函数尝试成为 leader，如果失败则使用 Resign 函数放弃竞选。</p><p>在函数执行完成后，如果当前 session 成为了 leader，它将会监视比当前 key revision 小的 key，等待这些 key 被删除。如果有一个或多个 key 被删除，那么这些 key 的删除操作将会返回。如果在等待期间 context 被取消，那么当前 session 将会放弃 leadership。</p><p>总之，该方法的作用是让多个会话竞选成为 leader，从而实现分布式系统中的 leader 选举</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> Golang </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借助etcd进行分布式服务leader选举（一）</title>
      <link href="/2022/03/28/%E5%80%9F%E5%8A%A9etcd%E8%BF%9B%E8%A1%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1leader%E9%80%89%E4%B8%BE/"/>
      <url>/2022/03/28/%E5%80%9F%E5%8A%A9etcd%E8%BF%9B%E8%A1%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1leader%E9%80%89%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们的管控项目是按地域部署，为了保证服务高可用，每个管控组件都部署2份，但是同时只有1个(<code>Leader</code>)对外提供服务，当<code>Leader</code>服务挂掉时，我们需要从<code>Follower</code>服务中重新选举一个服务来当<code>Leader</code>，复杂的方式是通过<code>Raft</code>协议去协商，简单点，可以通过分布式锁的思路来做。</p><p>而我们的项目就是通过<code>etcd</code>的分布式锁来实现的。在服务启动时，会尝试去进行<code>leader</code>竞争，成为<code>leader</code>的才能对外提供服务。</p><p>我在本地实现了个最基础版的<code>leader</code>选举代码</p><p>&emsp;</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>所有的<code>Follower</code>服务去竞争同一把锁，并给这个锁设置一个过期时间</li><li>只会有一个<code>Follower</code>服务取到锁，这把锁的值就为它的标识，他就变成了<code>Leader</code>服务</li><li>其他<code>Follower</code>服务竞争失败后，去获取锁得到的当前的<code>Leader</code>服务标识，与之通信</li><li><code>Leader</code>服务需要在锁过期之前不断的续期，证明自己是健康的</li><li>所有<code>Follower</code>服务监控这把锁是否还被<code>Leader</code>服务持有，如果没有，就跳到了第1步</li></ol><p>&emsp;</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>该段代码实现了基于<code>etcd</code>的分布式<code>leader</code>选举算法，可以协调多个客户端对<code>leader</code>的竞争，并在<code>leader</code>节点上周期性地更新<code>key-value</code>以维持其<code>leader</code>地位。</p><p>当然<code>etcd</code>提供的有选举<code>SDK</code>，我自己简单实现了下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/coreos/etcd/clientv3&quot;</span></span><br><span class="line"><span class="string">&quot;go.etcd.io/etcd/clientv3/concurrency&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">leaderKey = <span class="string">&quot;/leader&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建etcd客户端</span></span><br><span class="line">etcdClient, err := clientv3.New(clientv3.Config&#123;</span><br><span class="line"><span class="comment">// etcd集群的地址</span></span><br><span class="line">Endpoints: []<span class="keyword">string</span>&#123;<span class="string">&quot;http://localhost:12379&quot;</span>&#125;,</span><br><span class="line"><span class="comment">// 连接etcd的超时时间</span></span><br><span class="line">DialTimeout: time.Second * <span class="number">5</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> etcdClient.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建会话</span></span><br><span class="line">session, err := concurrency.NewSession(etcdClient)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> session.Close()</span><br><span class="line"></span><br><span class="line">mutex := concurrency.NewMutex(session, leaderKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 竞争leader的key</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 尝试获得锁</span></span><br><span class="line"><span class="keyword">if</span> err := mutex.Lock(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;failed to acquire lock:&quot;</span>, err)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成为leader，打印当前服务的IP地址</span></span><br><span class="line">fmt.Println(<span class="string">&quot;success to acquire lock, I&#x27;m the leader, my IP address is xxx.xxx.xxx.xxx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 周期性地续约leader的key</span></span><br><span class="line">ticker := time.NewTicker(time.Second * <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-session.Done():</span><br><span class="line"><span class="comment">// session已经过期，释放锁</span></span><br><span class="line">mutex.Unlock(context.Background())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line"><span class="comment">// 续约leader的key</span></span><br><span class="line"><span class="keyword">if</span> _, err := etcdClient.Put(context.Background(), leaderKey, <span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, clientv3.WithLease(session.Lease())); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;failed to update leader key:&quot;</span>, err)</span><br><span class="line">mutex.Unlock(context.Background())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;续约成功...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
            <tag> Golang </tag>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stolon-keeper和sentinel的代码流程总结</title>
      <link href="/2022/01/16/Stolon-keeper%E5%92%8Csentinel%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/16/Stolon-keeper%E5%92%8Csentinel%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Keeper"><a href="#Keeper" class="headerlink" title="Keeper"></a>Keeper</h2><p><img src="https://user-images.githubusercontent.com/19164993/219954062-69b5601f-04fa-4282-a410-ebb38f2cea17.png" alt="keeper"></p><p>&emsp;</p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><img src="https://user-images.githubusercontent.com/19164993/219954066-558b9787-6b67-47da-8092-a3c92bad55d6.png" alt="sentinel"></p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 项目 </tag>
            
            <tag> 代码走读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL集群主备复制方式</title>
      <link href="/2021/11/16/PostgreSQL%E9%9B%86%E7%BE%A4%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/11/16/PostgreSQL%E9%9B%86%E7%BE%A4%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a><strong>复制方式</strong></h1><blockquote><p>一主一备是同步物理流复制</p><p><code>RO</code>是异步流复制</p></blockquote><p>当备机宕机后，如果此时主库有写操作，会写等待，此时管控会降为异步流复制模式，并重做备库</p><p>&emsp;</p><p>&emsp;</p><h1 id="设置synchronous-commit参数"><a href="#设置synchronous-commit参数" class="headerlink" title="设置synchronous_commit参数"></a><strong>设置<code>synchronous_commit</code>参数</strong></h1><p>这个参数用来设置事务提交返回客户端之前，一个事务是否需要等待 <code>WAL</code> 记录被写入磁盘。合法的值是<code>&#123;local,remote_write,remote_apply,on,off&#125;</code></p><ul><li><p><code>off</code>   级别最低</p><p>当数据库事务提交时不需要等待本地 <code>wal buffer</code> 写入 <code>wal</code> 日志，立刻向客户端返回成功</p></li></ul><ul><li><p><code>local</code></p><p>当事务提交时，写入本地磁盘即可</p></li><li><p><code>remote_write</code></p><p>表示流复制主库提交事务时，需等待备库接收主库发送的wal日志流并写入<strong>备节点操作系统缓存</strong>中，之后向客户端返回成功，这种情况下备库出现异常关闭时不会有已传送的wal日志丢失风险，但备机<code>OS</code>异常宕机就有已传送的<code>wal</code>丢失风险</p><p>备机只需写入缓存，不需要落盘</p></li></ul><ul><li><p><code>remote_apply</code>  级别最高</p><p>表示流复制主库提交事务时，需等待备库接收主库发送的wal流并写入wal文件，同时备库已经完成回放，之后才向客户端返回成功，简单的说<code>remote_apply</code> 表示本地<code>wal</code>已落盘，<strong>备库<code>wal</code>已落盘并且已经完成回放</strong>，这个设置保证了拥有两份持久化的<code>wal</code>，同时备库也已经完成了回放</p><p>备机要<code>wal</code>回放完</p></li><li><p><strong><code>on</code> (默认)</strong></p><p>1 为<code>on</code>且没有开启同步备库的时候,会当<code>wal</code>日志真正刷新到磁盘永久存储后才会返回客户端事务已提交成功,</p><p>2 当为<code>on</code>且开启了同步备库的时候(设置了<code>synchronous_standby_names</code>),必须要等事务日志刷新到本地磁盘,并且还要等远程<strong>备库也提交到磁盘</strong>才能返回客户端已经提交.</p><p>主备都要<code>wal</code>落盘</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现接口幂等性</title>
      <link href="/2021/10/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2021/10/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><p>什么是幂等性？一次和多次请求某一个资源，对资源本身所产生的的影响均与一次执行的影响相同。</p><p>幂等性是系统服务对外的一种承诺，承诺只要调用接口成功了，多次调用对系统的影响是<font color=orange>一致</font>的。</p><p>&emsp;</p><h2 id="幂等性与重复提交比较"><a href="#幂等性与重复提交比较" class="headerlink" title="幂等性与重复提交比较"></a>幂等性与重复提交比较</h2><p><strong>幂等性</strong> 更多使用的情况是第一次请求知道结果，但是由于网络抖动或连接超时等情况未进行正常返回，在这种情况下系统自动再次发起请求，其目的是确认第一次是否请求完成。</p><p><strong>重复提交</strong> 更多使用的情况是第一次请求成功或请求结果暂未返回的情况下，人为的进行多次操作。</p><p>&emsp;</p><h2 id="为什么需要保证接口的幂等性？"><a href="#为什么需要保证接口的幂等性？" class="headerlink" title="为什么需要保证接口的幂等性？"></a>为什么需要保证接口的幂等性？</h2><p>接口的幂等性非常重要，因为在实际的应用中，接口可能会被调用多次，例如在网络不稳定或者客户端重试的情况下。如果接口没有保证幂等性，那么就会导致数据或者业务逻辑出现不一致的情况。</p><p>例如，如果一个非幂等性的接口被调用两次，第一次调用时创建了一个资源，第二次调用时又创建了一个相同的资源，这样就会导致资源数量不一致。</p><p>&emsp;</p><h2 id="哪些场景需要保证幂等性"><a href="#哪些场景需要保证幂等性" class="headerlink" title="哪些场景需要保证幂等性"></a>哪些场景需要保证幂等性</h2><p><strong>前端重复提交表单</strong>：在填写一些表单数据的时候，用户点击提交按钮，但是由于网络波动导致服务端没有及时给用户返回提交成功的响应，致使用户认为没有成功提交而重复点击提交按钮，这样就会重复提交表单数据。</p><p>&emsp;</p><p><strong>超时重试机制</strong>：在分布式架构中，由于引入了网络通信导致一个请求除了成功和失败以外还多了一个未知的状态，也就是有可能这次请求在服务端执行成功了，由于网络故障等原因，客户端在一定时间内没有收到服务端的响应，于是客户端为了保证这次操作的成功会发起一个重试操作，导致同一个接口被重复调用了多次。</p><p>&emsp;</p><p><strong>MQ消息重复消费</strong>：正常情况下，消费者在消费消息的时候，消费完毕后会发送一个确认的信号（ACK）给消息队列，消息队列在收到确认信号（ACK）的时候就知道这条消息已经被成功消费了，于是就会把这条消息从消息队列中删除，但是可能由于网络波动等故障，这个确认的信号（ACK）没有传送到消息队列，导致消息队列会认为这条消息没有消费成功，于是消息队列会把这条消息发送给其他的消费者去消费，这样就导致消息被重复消费了。</p><p>&emsp;</p><h2 id="SQL-语句幂等性"><a href="#SQL-语句幂等性" class="headerlink" title="SQL 语句幂等性"></a>SQL 语句幂等性</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行多少次都不会对资源造成影响，查询具有天然的幂等性。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次状态都是一致的，这种场景是幂等操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> score <span class="operator">=</span> score<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>每次执行的结果都会发生变化，这种场景不是幂等操作。</p><p>根据具体场景看能否写成这样的 <font color=orange>SQL</font> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> score <span class="operator">=</span> score<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> score <span class="operator">=</span> <span class="number">59</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次分数都是一致的，这种场景是幂等操作。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次数据都是一致的，这种场景是幂等操作。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`name`, `status`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;tom&#x27;</span>, <span class="number">1</span>, <span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>每次执行的结果都会发生变化，这种场景不是幂等操作。</p><p>根据具体场景看能否为 <font color=orange>name</font> 创建一个唯一索引，或执行类型这样的 <font color=orange>SQL</font> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ... <span class="keyword">values</span> ... <span class="keyword">ON</span> DUPLICATE KEY UPDATE ...</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注意，要使用这条语句，前提条件是这个表必须有一个唯一索引或主键。</span><br></pre></td></tr></table></figure><p>&emsp;</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>以下是保证接口幂等性的几种常见方法。</p><h3 id="1-唯一标识符"><a href="#1-唯一标识符" class="headerlink" title="1. 唯一标识符"></a>1. 唯一标识符</h3><p>为了保证接口的幂等性，我们可以为每个请求生成一个唯一标识符。可以使用UUID或其他类似的方法生成这个标识符。这个标识符可以在服务器端存储，以确保同一请求只被处理一次。</p><p>在客户端发送请求时，我们需要将这个唯一标识符一起发送到服务器端。服务器端接收到请求后，可以检查这个唯一标识符是否已经处理过。如果已经处理过，就不再处理这个请求，而是直接返回结果。</p><p>&emsp;</p><h3 id="2-数据库唯一索引"><a href="#2-数据库唯一索引" class="headerlink" title="2. 数据库唯一索引"></a>2. 数据库唯一索引</h3><p><strong>适用于插入操作</strong>。</p><p>在设计表的时候我们可以规定一些在业务上唯一的字段（比如：身份证号、订单号），为这些字段建立一个唯一索引。在做插入操作的时候，第一次请求的数据可以插入成功。但后面的相同请求，插入数据时会报 <code>Duplicate entry &#39;xxx&#39; for key &#39;xxxxxxx&#39;</code> 异常，表示唯一索引有冲突。</p><blockquote><p>缺点：</p><p>效率不高，只支持插入操作，并且高并发下数据库压力比较大</p></blockquote><p>&emsp;</p><h3 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3. 乐观锁"></a>3. 乐观锁</h3><p>乐观锁是一种并发控制的方法。在Web开发中，乐观锁可以用来保证接口的幂等性。具体实现方法如下：</p><ul><li>当客户端发送请求时，服务器端首先读取当前资源的版本号。</li><li>服务器端根据客户端请求更新资源，并生成新的版本号。</li><li>服务器端将新的版本号返回给客户端。</li></ul><p>如果客户端重复发送请求，服务器端会检查请求中的版本号是否与当前资源的版本号相同。如果相同，说明这个请求已经被处理过，服务器端不会再次处理请求，直接返回结果。</p><p>&emsp;</p><h3 id="4-Token"><a href="#4-Token" class="headerlink" title="4. Token"></a>4. Token</h3><p>幂等性Token是一种用来保证接口幂等性的标识符。当客户端发送请求时，服务器端会为这个请求生成一个幂等性Token。这个Token可以在服务器端存储，以确保同一请求只被处理一次。</p><p>在客户端发送请求时，需要将这个幂等性Token一起发送到服务器端。服务器端接收到请求时，会检查这个Token是否已经处理过。如果已经处理过，就不再处理这个请求，而是直接返回结果。</p><p>&emsp;</p><h3 id="5-Redis-Token"><a href="#5-Redis-Token" class="headerlink" title="5. Redis+Token"></a>5. Redis+Token</h3><p><img src="https://user-images.githubusercontent.com/19164993/219409369-46340421-09ca-494b-b688-1c5eb9bdf39f.png" alt="redis-token"></p><p>&emsp;</p><h3 id="6-状态机"><a href="#6-状态机" class="headerlink" title="6. 状态机"></a>6. 状态机</h3><p>有的业务表是有状态的，可以根据状态字段保证接口的幂等性。</p><p>比如在云数据库管控系统中，数据库实例的状态有(初始化、运行中、变配中)等状态，当一个请求发起实例变配时，会首先去查询表中该实例的状态，只有在运行中状态的实例才可以执行成功，并把状态改为变配中，此时如果有重复的请求过来，查询到状态是变配中，直接返回，不允许操作。</p><p>&emsp;</p><h3 id="7-防重表"><a href="#7-防重表" class="headerlink" title="7. 防重表"></a>7. 防重表</h3><p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。</p><p>针对这种情况，可以通过建防重表来解决问题。</p><p>该表可以只包含两个字段：id 和 唯一索引，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：gouri_123</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈国产数据库在金融界的应用-概念篇</title>
      <link href="/2021/10/10/%E6%B5%85%E8%B0%88%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E9%87%91%E8%9E%8D%E7%95%8C%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%80)/"/>
      <url>/2021/10/10/%E6%B5%85%E8%B0%88%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E9%87%91%E8%9E%8D%E7%95%8C%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>移动互联网发展至今，移动支付占据了90%以上的交易量，传统的金融IT架构面临着海量的高并发响应、处理速度以及安全性的挑战。<br>金融行业的数据库市场，尤其是银行的核心交易系统，一直是 <font color=orange>Oracle、DB2</font> 这类美国传统商业数据库的天下，从银行系统的角度来看，所承担的业务量将是海量式的增长，同时也不可避免带来金融行业数据安全、业务安全方面的风险，传统数据库显然不满足需求了。</p><h2 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h2><p>随着国家有关部门近年来陆续出台相关政策指导文件，推动探索安全可控的金融科技产品，加强银行业信息安全建设，由新型分布式数据库替代传统集中式架构，成为金融级数据库市场的主流趋势。<br>央行19年发布《金融科技(FinTech)发展规划(2019-2021年)》也强调，加强分布式数据库研发应用，为分布式数据库在金融领域的全面应用探明路径。国内众多金融政企机构纷纷开始探索改造原有IT系统，对国产化数据库的需求日益强烈。</p><h2 id="云时代"><a href="#云时代" class="headerlink" title="云时代"></a>云时代</h2><p>在数字经济时代的今天，各行各业都在加速<mark class="hl-label red">上云</mark> ，金融业也行驶在数字化转型的浪潮中。在其背后，数据库承载着金融机构的核心数据，是金融科技业务创新的基础和底座，阿里云、腾讯云、华为云三家中国云计算厂商巨头纷纷推出了自己的国产云数据库产品。</p><h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><h3 id="1、TBase"><a href="#1、TBase" class="headerlink" title="1、TBase"></a>1、TBase</h3><p>分布式HTAP数据库 <font color=orange>TBase（TencentDB for TBase）</font>是腾讯自主研发的分布式数据库系统，集高扩展性、高SQL兼容度、完整的分布式事务支持、多级容灾能力以及多维度资源隔离等能力于一身。TBase 强大的安全和容灾能力，已经成功应用在金融、政府、电信、医疗等行业的核心业务系统。同时，TBase 采用无共享的集群架构，为用户提供容灾、备份、恢复、监控、安全、审计等全套解决方案，适用于GB～PB级的海量 HTAP 场景</p><mark class="hl-label red">TBase</mark> 已经覆盖多个行业的标杆用户，其中对内支持了微信广告、微信支付、腾讯地图以及腾讯游戏等海量数据业务，一笔交易毫秒内即可完成，支撑了微信支付50倍的交易增长<p><img src="https://user-images.githubusercontent.com/37777293/136667363-b81ed98b-a31c-43ba-b187-17d99b941a41.png" alt="TBase"></p><h3 id="2、TDSQL"><a href="#2、TDSQL" class="headerlink" title="2、TDSQL"></a>2、TDSQL</h3><p>分布式数据库<font color=orange>TDSQL（Tencent Distributed SQL）</font>是腾讯打造的一款分布式数据库产品，具备强一致高可用、全球部署架构、分布式水平扩展、高性能、企业级安全等特性，同时提供智能 DBA、自动化运营、监控告警等配套设施，为客户提供完整的分布式数据库解决方案。<br>目前 TDSQL 已经为超过<mark class="hl-label red">600+</mark> 的政企和金融机构提供数据库的公有云及私有云服务，客户覆盖银行、保险、证券、互联网金融、计费、第三方支付、物联网、互联网+、政务等领域。TDSQL 亦凭借其高质量的产品及服务，获得了多项国际和国家认证，得到了客户及行业的一致认可<br><img src="https://user-images.githubusercontent.com/37777293/136667439-a07a62f6-f1c2-4611-9796-3d957a937f8f.png" alt="TDSQL"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 金融 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL是如何实现MVCC的</title>
      <link href="/2021/07/16/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVCC%E7%9A%84/"/>
      <url>/2021/07/16/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVCC%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于 (隐藏字段 + <code>undolog</code> + <code>readView</code>)来实现<code>MVCC</code>的</p><ul><li><p><code>undolog</code> ：</p><p>修改数据时，将该记录写入到版本链中，<code>undolog</code>， 每次放在头部。</p><p>&emsp;</p></li><li><p>行隐藏字段：</p><p> <code>db_trx_id</code>：事务ID，全局唯一</p><p> <code>roll_pointer</code> 版本链指针</p></li></ul><p><img src="https://user-images.githubusercontent.com/19164993/219787502-1fdd650c-96c2-4128-b882-0e0652743133.png" alt="mvcc"></p><p><code>ReadView</code>中的统计值：</p><ul><li><code>m_ids</code>  当前活跃的事务集合（所有未提交的事务）</li><li><code>min_trx_id</code>   <code>m_ids</code>中最小的。即最小的活跃事务ID</li><li><code>max_trx_id</code> 版本链头的事务+1。<code>max_trx_id</code>并不是<code>m_ids</code>中的最大值，事务ID是递增分配的。比方说现在有<code>id</code>为1，2，3这三个事务，之后<code>id</code>为3的事务提交了。那么一个新的读事务在生成<code>ReadView</code>时，<code>m_ids</code>就包括1和2，<code>min_trx_id</code>的值就是1，<code>max_trx_id</code>的值就是4</li><li><code>creator_trx_id</code> 当前创建这个视图的事务ID</li></ul><p>&emsp;</p><p>根据上图，当前事务ID为201时，统计值如下：</p><ul><li><p><code>m_ids</code> = [90,100, 200]</p></li><li><p><code>min_tx_id</code> = 90</p></li><li><p><code>max_tx_id</code> = 200 + 1 = 201</p></li><li><p><code>creator_trx_id</code> = 201</p></li></ul><p>&emsp;</p><h2 id="判断规则"><a href="#判断规则" class="headerlink" title="判断规则"></a>判断规则</h2><p>从<code>undolog</code>链表头部开始遍历</p><p>伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (该记录trx_id == 当前自己的事务id) &#123;</span><br><span class="line">     那么就是当前事务自己修改的，当然可以访问  <span class="literal">true</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(该记录trx_id &lt; min_tx_id) &#123;</span><br><span class="line">     那么该记录的事务在自己生成readView前就已经提交了，可以被当前事务访问  <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(该记录trx_id &gt;= max_tx_id) &#123;</span><br><span class="line">      那么该事务是在readview生成之后才开启，不能被当前事务访问 <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(min_tx_id &lt; 该记录trx_id &lt; max_tx_id) &#123;</span><br><span class="line">        <span class="keyword">if</span>(该记录trx_id 在 m_ids中）&#123;</span><br><span class="line">          说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问  <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          说明创建ReadView时生成该版本的事务已经被提交，可以被当前事务访问  <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL主从搭建</title>
      <link href="/2021/07/14/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/07/14/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Master配置"><a href="#一、Master配置" class="headerlink" title="一、Master配置"></a>一、Master配置</h1><p>1、修改<code>postgresql.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span>   <span class="comment">#监听的IP地址</span></span><br><span class="line">wal_level = hot_standby  <span class="comment">#启用热备模式</span></span><br><span class="line">synchronous_commit = on  <span class="comment">#开启同步复制</span></span><br><span class="line">max_wal_senders = 2      <span class="comment">#同步最大的进程数量</span></span><br><span class="line">wal_sender_timeout = 60s <span class="comment">#流复制主机发送数据的超时时间</span></span><br><span class="line">max_connections = 100    <span class="comment">#最大连接数，从库的max_connections必须要大于主库的</span></span><br></pre></td></tr></table></figure><p>2、创建同步账号，用于流复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user replica with password <span class="string">&#x27;123456&#x27;</span> replication;</span><br></pre></td></tr></table></figure><p>3、修改<code>pg_hba.conf</code>，允许从库地址通信</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host replication replica 主机ip/32 md5   <span class="comment">#在master上可以执行pg_basebackup</span></span><br><span class="line">host replication replica 备机ip/32 md5   <span class="comment">#slave可以和master正常通信</span></span><br></pre></td></tr></table></figure><p>4、重新加载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl -D /data/pg_data/data reload</span><br></pre></td></tr></table></figure><p>&emsp;</p><h1 id="二、Slave配置"><a href="#二、Slave配置" class="headerlink" title="二、Slave配置"></a>二、Slave配置</h1><p>1、在<code>slave</code>上运行<code>pg_basebackup</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_basebackup -D /data/pg_data/data -h &lt;主节点IP&gt; -p 5432 -U replica -X stream -P</span><br></pre></td></tr></table></figure><p>2、创建<code>recovery.conf</code>文件，修改如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">standby_mode = on     <span class="comment">#声明此节点为从库</span></span><br><span class="line">primary_conninfo = <span class="string">&#x27;host=&lt;主节点IP&gt; port=5432 user=replica password=123456&#x27;</span> <span class="comment">#对应主库的连接信息</span></span><br><span class="line">recovery_target_timeline = <span class="string">&#x27;latest&#x27;</span> <span class="comment">#流复制同步到最新的数据</span></span><br></pre></td></tr></table></figure><p>3、修改<code>postgresql.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max_connections = 1000             <span class="comment"># 最大连接数，从节点需设置比主节点大</span></span><br><span class="line">hot_standby = on                   <span class="comment"># 开启热备</span></span><br><span class="line">max_standby_streaming_delay = 30s  <span class="comment"># 数据流备份的最大延迟时间</span></span><br><span class="line">wal_receiver_status_interval = 1s  <span class="comment"># 从节点向主节点报告自身状态的最长间隔时间</span></span><br><span class="line">hot_standby_feedback = on          <span class="comment"># 如果有错误的数据复制向主进行反馈</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云PG实例创建流程</title>
      <link href="/2021/07/11/%E8%85%BE%E8%AE%AF%E4%BA%91PG%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/07/11/%E8%85%BE%E8%AE%AF%E4%BA%91PG%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/19164993/219874781-19ca5d30-b33d-4a76-8cae-844215a07016.jpeg" alt="pg-instance-new-init"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> 腾讯云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Stolon快速构建PostgreSQL集群</title>
      <link href="/2021/06/21/%E5%9F%BA%E4%BA%8EStolon%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAPostgreSQL%E9%9B%86%E7%BE%A4/"/>
      <url>/2021/06/21/%E5%9F%BA%E4%BA%8EStolon%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAPostgreSQL%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p>准备3台机器模拟PG HA架构，其中etcd和proxy为单节点，便于测试环境搭建</p><table><thead><tr><th>组件</th><th>ip</th><th>port</th><th>角色</th></tr></thead><tbody><tr><td>etcd</td><td>192.168.5.220</td><td>2379</td><td></td></tr><tr><td>postgres0</td><td>192.168.0.200</td><td>5432</td><td>master</td></tr><tr><td>postgres1</td><td>192.168.0.220</td><td>5432</td><td></td></tr><tr><td>proxy</td><td>192.168.5.220</td><td>25432</td><td></td></tr></tbody></table><p>&emsp;</p><h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><p>1、初始化集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stolonctl --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints= http://192.168.5.220:2379  init</span><br></pre></td></tr></table></figure><p>2、启动一个sentinel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stolon-sentinel --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints=http://192.168.5.220:2379</span><br><span class="line"></span><br><span class="line">&gt;&gt; sentinel id id=66613766</span><br><span class="line">&gt;&gt; Trying to acquire sentinels leadership</span><br><span class="line">&gt;&gt; sentinel leadership acquired</span><br></pre></td></tr></table></figure><p>3、启动一个keeper (主 postgres0) (第一个启动的是主)</p><p>这将启动一个uid为postgres0的keeper进程，监听在192.168.5.200:5432 上，在data/postgres0/postgres/ 目录初始化出一个PG实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">stolon-keeper --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints= http://192.168.5.220:2379 --uid postgres0 --data-dir data/postgres0 --pg-su-password=supassword --pg-repl-username=repluser --pg-repl-password=replpassword --pg-listen-address=192.168.5.200</span><br><span class="line"></span><br><span class="line">&gt;&gt; exclusive lock on data dir taken</span><br><span class="line">&gt;&gt; keeper uid uid=postgres0</span><br><span class="line">&gt;&gt; stopping database</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; current db UID different than cluster data db UID db= cdDB=2a87ea79</span><br><span class="line">&gt;&gt; initializing the database cluster</span><br><span class="line">&gt;&gt; cannot get configured pg parameters error=dial tcp 127.0.0.1:5432: getsockopt: connection refused</span><br><span class="line">&gt;&gt; starting database</span><br><span class="line">&gt;&gt; error getting pg state error=pq: password authentication failed <span class="keyword">for</span> user <span class="string">&quot;repluser&quot;</span></span><br><span class="line">&gt;&gt; setting roles</span><br><span class="line">&gt;&gt; setting superuser password</span><br><span class="line">&gt;&gt; superuser password <span class="built_in">set</span></span><br><span class="line">&gt;&gt; creating replication role</span><br><span class="line">&gt;&gt; replication role created role=repluser</span><br><span class="line">&gt;&gt; stopping database</span><br><span class="line">&gt;&gt; our db requested role is master</span><br><span class="line">&gt;&gt; starting database</span><br><span class="line">&gt;&gt; already master</span><br><span class="line">&gt;&gt; postgres parameters changed, reloading postgres instance</span><br><span class="line">&gt;&gt; reloading database configuration</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>此时setinel将选举该实例为master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; trying to find initial master</span><br><span class="line">&gt;&gt; initializing cluster keeper=postgres0</span><br><span class="line">&gt;&gt; received db state <span class="keyword">for</span> unexpected db uid receivedDB= db=2a87ea79</span><br><span class="line">&gt;&gt; waiting <span class="keyword">for</span> db db=2a87ea79 keeper=postgres0</span><br><span class="line">&gt;&gt; waiting <span class="keyword">for</span> db db=2a87ea79 keeper=postgres0</span><br><span class="line">&gt;&gt; waiting <span class="keyword">for</span> db db=2a87ea79 keeper=postgres0</span><br><span class="line">&gt;&gt; db initialized db=2a87ea79 keeper=postgres0</span><br></pre></td></tr></table></figure><p>4、再启动一个keeper (备 postgres1)</p><p>这个实例将和master建立复制关系，成为备机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stolon-keeper --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints= http://192.168.5.220:2379 --uid postgres1 --data-dir data/postgres1 --pg-su-password=supassword --pg-repl-username=repluser --pg-repl-password=replpassword --pg-listen-address=192.168.5.220</span><br><span class="line"></span><br><span class="line">&gt;&gt; exclusive lock on data dir taken</span><br><span class="line">&gt;&gt; keeper uid uid=postgres1</span><br><span class="line">&gt;&gt; stopping database</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; current db UID different than cluster data db UID db= cdDB=63343433</span><br><span class="line">&gt;&gt; database cluster not initialized</span><br><span class="line">&gt;&gt; our db requested role is standby followedDB=2a87ea79</span><br><span class="line">&gt;&gt; running pg_basebackup</span><br><span class="line">&gt;&gt; sync succeeded</span><br><span class="line">&gt;&gt; starting database</span><br><span class="line">&gt;&gt; postgres parameters changed, reloading postgres instance</span><br><span class="line">&gt;&gt; reloading database configuration</span><br><span class="line">&gt;&gt; our db requested role is standby followedDB=2a87ea79</span><br><span class="line">&gt;&gt; already standby</span><br></pre></td></tr></table></figure><p>&emsp;</p><h2 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h2><p><strong>keeper</strong></p><p>Keeper 等于是在PG上层包装了一层，内嵌了很多PG主从初始化、切换以及一些Failover处理的逻辑。而Keeper做这些操作的依据就是Sentinel生成的Cluster Data（存储在Etcd），Keeper会一直轮询集群状态。</p><p>&emsp;</p><p><strong>sentinel</strong></p><p>Sentinel用来选主、以及监控所有PG实例的健康状态，会在Master不可用的时候，选举出最合适的Slave来设置成新的Master（通过PG Xlog来判断）</p><p>&emsp;</p><p><strong>Proxy</strong></p><p>Sentinel + Proxy 有点像Redis的哨兵。Proxy 是客户端的流量入口，会将所有的流量转发到Master，如果发生了主备切换，Proxy也会关闭旧的Master的连接。至于Proxy是如何判断Master节点，也是依赖Sentinel生成的Cluster Data。Proxy 实现上依赖的是一个自行开发的网络库，支持代理转发流量，同时支持对Socket FD设置TCP Keepalived参数，通过Goroutine而不是线程来处理请求，可以极大的减少资源开销。综上，可以看到Sentinel + Proxy组合起来承担了类似Redis哨兵的功能</p><p>&emsp;</p><h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>1、stolonctl init      集群初始化</p><p>将集群的元数据信息、ClusterSpec等存放在etcd上</p><p>&emsp;</p><p>2、 stolon-sentinel   启动1个sentinel  </p><p> 1）最早创建的sentinel成为leader。借助etcd的leader选举机制</p><p> 2） 把sentinel的信息存放在etcd上</p><p> 3）从etcd拉取keeper的信息</p><p> 4）如果当前sentinel不是leader，就直接返回</p><p> 5） 监控keeper，（健康检查、如果发现当前集群还没有master，就将发现的第一个keeper设置为master</p><p>&emsp;</p><p>3、stolon-keeper  启动1个keeper</p><p> 1）initdb                    初始化数据库</p><p> 2）postgres -D /dir   启动数据库</p><p> 3）直到出现postmaster.pid文件，检查下pid，启动成功</p><p>&emsp;</p><p>4、再次创建1个sentinel和keeper</p><p>keeper将备机的复制信息写入recovery.conf文件，运行 pg_basebackup 建立同步</p><p>该sentinel不工作</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何减少代码里的if/else</title>
      <link href="/2020/10/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/"/>
      <url>/2020/10/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>if/else是高级编程语言中最基础的功能，虽然 if/else 是必须的，但滥用 if/else，特别是各种大量的if/else嵌套，会对代码的可读性、可维护性造成很大伤害，对于阅读代码的人来说就是一场灾难。</p><p>本系列博客的目的不是消除if/else,而是如何“写好”if/else</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h2><p>根据if/else的使用方式和场景，大概有如下解决方法</p><blockquote><ul><li>多态</li><li>表驱动</li><li>职责链模式</li><li>卫语句</li><li>Optional</li><li>调整判断逻辑，抽取方法，逻辑优化</li></ul></blockquote><p>本篇博客我介绍的是<strong>表驱动</strong>，后续博客会介绍其他案例<br>首先来看下最简单的if…else if…场景，也是经常可以在代码中看到的案例</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>有如下业务代码demo，根据type值，判断然后返回设备的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑表达模式固定的 if…else</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着时间的积累和项目的迭代，可能会增加越来越多的类型，那么后人会继续增加if/else分支，代码中存在的分支判断就会越来越多，当分支数量实在是多的难以维护的时候，我们就要考虑下，有办法能让这些代码变得更优雅吗？</p><p>可能有的人会说用switch/case来重构代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，换成switch/case也是一样，后续也要维护大量case分支，特别是当同样的逻辑判断出现在多个地方的时候，代码的可读性和维护难易程度将变得非常的糟糕。每次修改时，你必须找到所有有逻辑分支的地方，并修改它们</p><p>下面，我就来介绍一种针对这种if/else判断的最简单的重构方式，那就是使用<strong>表驱动</strong></p><h2 id="4-表驱动重构代码"><a href="#4-表驱动重构代码" class="headerlink" title="4. 表驱动重构代码"></a>4. 表驱动重构代码</h2><p>表驱动方法（Table-Driven Methods），《代码大全》对此进行了详细地讲解。</p><blockquote><p>表驱动法是一种编程模式（Scheme），从表里面查找信息而不使用逻辑语句（if 和case） 它的好处是消除代码里面到处出现的if、else、switch语句，让凌乱代码变得简明和清晰。<br>对简单情况而言，表驱动方法可能仅仅使逻辑语句更容易和直白，但随着逻辑的越来越复杂，表驱动法就愈发有吸引力。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer, String&gt; deviceType2NameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    deviceType2NameMap.put(<span class="number">1</span>, <span class="string">&quot;ONT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">2</span>, <span class="string">&quot;OLT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">3</span>, <span class="string">&quot;ONU&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">4</span>, <span class="string">&quot;MXU&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static方式可以在类初始化时就加载，当然，如果不想写成static，也可以自行加载</p></blockquote><p>那么，查询的时候，直接get就可以了，而且不需要对key值进行额外的判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String deviceName = deviceType2NameMap.get(type);</span><br></pre></td></tr></table></figure><p>当然，还有一种逻辑固定的if/else也很常见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;run&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doRun(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;fly&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doFly(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sleep&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doSleep(param);</span><br><span class="line">&#125; <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>这里分支后的执行过程换成了函数，不同的行为执行不同的函数<br>转换为<strong>表驱动</strong>方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假定上述的param类型为int</span></span><br><span class="line">Map&lt;String, Consumer&lt;Integer&gt;&gt; actionMappings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">initActionMap()&#123;</span><br><span class="line"><span class="comment">// 使用方法引用替换Lambda表达式</span></span><br><span class="line">    <span class="comment">// Test::doRun等价于param -&gt; doRun(param)</span></span><br><span class="line">actionMappings.put(<span class="string">&quot;run&quot;</span>, Test::doRun);</span><br><span class="line">actionMappings.put(<span class="string">&quot;fly&quot;</span>, Test::doFly);</span><br><span class="line">actionMappings.put(<span class="string">&quot;sleep&quot;</span>, Test::doSleep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doRun(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doFly(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doSleep(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionMappings.get(<span class="string">&quot;run&quot;</span>).accept(param);</span><br></pre></td></tr></table></figure><p>可能有人不清楚<strong>Consumer</strong>是个什么，为什么最后又执行了<strong>accept</strong>方法<br>这里简单说下</p><blockquote><ul><li>Consumer&lt;T&gt;是Java8以后提供的函数式接口</li><li>T：入参类型；没有出参</li><li>调用方法：void accept(T t);</li><li>因为没有出参，常用于打印、发送短信等<strong>消费动作</strong></li></ul></blockquote><p>由此可见，表驱动的优势</p><blockquote><ul><li>数据逻辑分离，保证在修改数据时，不会对逻辑产生影响。</li><li>单元测试时可以注入表格，只要数据可以转换成表，我们可以输入任意形式的数据。</li><li>逻辑固定写死在程序中，因为修改逻辑成本高，数据则是灵活变换的，因为修改数据成本低。</li><li>保证多人开发时代码的稳健性，简单的逻辑易于读懂易于维护，并且多人使用时，只用修改数据段即可，而数据本身不需要再测试。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if </tag>
            
            <tag> 优化 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Autowired和Resource的区别</title>
      <link href="/2019/01/06/@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/01/06/@Autowired%E5%92%8C@Resource%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行属性注入时，<code>@Autowired</code>和<code>@Resource</code>这两个注解经常在项目中可以看到，所以探讨下这两个注解有什么区别</p><p>&emsp;</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>接口有单一实现类时，针对接口的注入，两者可以互相替换，功能是一样的。</p><p>&emsp;</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>1、<code>@Autowired</code>是<code>Spring</code>中的注解。<code>@Resource</code>是<code>Java</code>中的注解</p><p>2、<code>@Resource</code>可以指定<code>byName</code>、<code>byType</code>策略注入，默认是<code>byName</code>，如果根据<code>name</code>找不到，就会根据<code>type</code>注入。</p><p>​      <code>@Autowired</code>只能根据<code>type</code>注入，如果有多个<code>type</code>类型，可以配合<code>@Qualifier</code>注解来根据名称注入</p><p>&emsp;</p><h2 id="代码展示-Autowired"><a href="#代码展示-Autowired" class="headerlink" title="代码展示-@Autowired"></a>代码展示-@Autowired</h2><p>@Autowired源码定义：</p><p><img src="https://user-images.githubusercontent.com/19164993/219868307-e316aed0-b1cc-4882-af44-0f034b72f9a5.png" alt="auto"></p><p>首先定义一个需要被注入的接口类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Long id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就演示注入<code>UserRepository</code>的过程</p><h4 id="1-Autowired在构造函数上的使用"><a href="#1-Autowired在构造函数上的使用" class="headerlink" title="1. @Autowired在构造函数上的使用"></a>1. @Autowired在构造函数上的使用</h4><p>在构造函数上加上<code>@Autowired</code>注解，<code>Spring</code>就能够自动装配依赖。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>@Autowired</code>注解来自动装配<code>UserRepository</code>类型的依赖。由于没有使用任何的限定符<code>（Qualifier）</code>，<code>Spring</code>会根据<code>type</code>来匹配依赖关系。需要注意的是，使用构造函数注入时，不需要显式地声明依赖关系的成员变量。</p><p>&emsp;</p><h4 id="2-Autowired在方法上的使用"><a href="#2-Autowired在方法上的使用" class="headerlink" title="2. @Autowired在方法上的使用"></a>2. @Autowired在方法上的使用</h4><p>可以在方法上声明需要自动装配的依赖。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，使用<code>@Autowired</code>注解来自动装配<code>UserRepository</code>类型的依赖。需要注意的是，方法名并不是固定的，可以根据自己的需要进行命名。</p><p>&emsp;</p><h4 id="3-Autowired在参数上的使用"><a href="#3-Autowired在参数上的使用" class="headerlink" title="3. @Autowired在参数上的使用"></a>3. @Autowired在参数上的使用</h4><p>还可以在方法参数上使用它。下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    private final UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public UserServiceImpl(UserRepository userRepository) &#123;</span><br><span class="line">        this.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserService(@Autowired UserService userService) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;</p><h4 id="4-Autowired在字段上的使用"><a href="#4-Autowired在字段上的使用" class="headerlink" title="4. @Autowired在字段上的使用"></a>4. @Autowired在字段上的使用</h4><p>在字段上使用时最常用的用法。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;</p><h4 id="5-Autowired在注解类型上的使用"><a href="#5-Autowired在注解类型上的使用" class="headerlink" title="5. @Autowired在注解类型上的使用"></a>5. @Autowired在注解类型上的使用</h4><p>除了在构造函数、方法、参数和字段上使用<code>@Autowired</code>注解，还可以在注解类型上使用它。这样，<code>Spring</code>会自动装配标记了这个注解的类。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，定义了一个注解类型<code>@CurrentUser</code>，并使用<code>@Autowired</code>注解标记它。这意味着，当在其他类中使用了<code>@CurrentUser</code>注解时，<code>Spring</code>会自动装配这个依赖。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserRepository userRepository, <span class="meta">@CurrentUser</span> User currentUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="有多个类型的bean怎么办"><a href="#有多个类型的bean怎么办" class="headerlink" title="有多个类型的bean怎么办?"></a>有多个类型的bean怎么办?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还按照上面根据类型注入，就会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 因为有2个类型，这里出现异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1、使用@Autowired</p><p>1.1 使用@Qualifier注解</p><p>可以使用<code>@Qualifier</code>注解指定需要注入的<code>Bean</code>的名称。需要注意的是，这里的名称是<code>Bean</code>的名称，而不是属性名或类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userRepositoryImpl&quot;)</span>   <span class="comment">// 指定Bean的名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;userRepositoryImpl2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userRepositoryImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 会自动装配名称为&quot;userRpositoryImpl&quot;的Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2 使用@Primary注解</p><p>还可以使用<code>@Primary</code>注解标记一个<code>Bean</code>为首选<code>Bean</code>。这样在自动装配时，<code>Spring</code>会优先选择带有<code>@Primary</code>注解的<code>Bean</code>进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Primary</span>    <span class="comment">// 指定首选Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 会自动装配类型为UserRepository，且选择了带有@Primary注解的Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;</p><p>2、使用@Resource</p><p>2.1 按类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(type = UserRepositoryImpl2.class)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 会自动装配类型为UserRepositoryImpl2的Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 按名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userRepositoryImpl&quot;)</span>   <span class="comment">// 指定Bean的名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;userRepositoryImpl2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl2</span> <span class="keyword">implements</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;userRepositoryImpl2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 会自动装配名称为&quot;userRepositoryImpl2&quot;的Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在最前面的话</title>
      <link href="/2019/01/02/hello-world/"/>
      <url>/2019/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome! 这是我的第一篇博客</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>及时总结和分享<br>包括但不限于以下内容：</p><blockquote><ul><li>技术总结</li><li>行业思考</li><li>刷题笔记</li><li>职场经验</li></ul></blockquote><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>后续会将本地的笔记和记录整理成博客文章发布</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>写在最前面的话</title>
      <link href="/2021/10/05/hello-world/"/>
      <url>/2021/10/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome! 这是我的第一篇博客</p><p>以前的技术博客都保存在公司内网中，外网无法浏览，因此搭建了该网站用来记录技术上的点点滴滴，当然，可能包含其他</p><p>什么是好习惯？及时总结</p><h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何减少代码里的if/else</title>
      <link href="/2021/09/30/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/"/>
      <url>/2021/09/30/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>if/else是高级编程语言中最基础的功能，虽然 if/else 是必须的，但滥用 if/else，特别是各种大量的if/else嵌套，会对代码的可读性、可维护性造成很大伤害，对于阅读代码的人来说就是一场灾难。</p><p>本系列博客的目的不是消除if/else,而是如何“写好”if/else</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h2><p>根据if/else的使用方式和场景，大概有如下解决方法</p><blockquote><ul><li>多态</li><li>表驱动</li><li>职责链模式</li><li>卫语句</li><li>Optional</li><li>调整判断逻辑，抽取方法，逻辑优化</li></ul></blockquote><p>本篇博客我介绍的是<strong>表驱动</strong>，后续博客会介绍其他案例<br>首先来看下最简单的if…else if…场景，也是经常可以在代码中看到的案例</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>有如下业务代码demo，根据type值，判断然后返回设备的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑表达模式固定的 if…else</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着时间的积累和项目的迭代，可能会增加越来越多的类型，那么后人会继续增加if/else分支，代码中存在的分支判断就会越来越多，当分支数量实在是多的难以维护的时候，我们就要考虑下，有办法能让这些代码变得更优雅吗？</p><p>可能有的人会说用switch/case来重构代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，换成switch/case也是一样，后续也要维护大量case分支，特别是当同样的逻辑判断出现在多个地方的时候，代码的可读性和维护难易程度将变得非常的糟糕。每次修改时，你必须找到所有有逻辑分支的地方，并修改它们</p><p>下面，我就来介绍一种针对这种if/else判断的最简单的重构方式，那就是使用<strong>表驱动</strong></p><h2 id="4-表驱动重构代码"><a href="#4-表驱动重构代码" class="headerlink" title="4. 表驱动重构代码"></a>4. 表驱动重构代码</h2><p>表驱动方法（Table-Driven Methods），《代码大全》对此进行了详细地讲解。</p><blockquote><p>表驱动法是一种编程模式（Scheme），从表里面查找信息而不使用逻辑语句（if 和case） 它的好处是消除代码里面到处出现的if、else、switch语句，让凌乱代码变得简明和清晰。<br>对简单情况而言，表驱动方法可能仅仅使逻辑语句更容易和直白，但随着逻辑的越来越复杂，表驱动法就愈发有吸引力。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer, String&gt; deviceType2NameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    deviceType2NameMap.put(<span class="number">1</span>, <span class="string">&quot;ONT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">2</span>, <span class="string">&quot;OLT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">3</span>, <span class="string">&quot;ONU&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">4</span>, <span class="string">&quot;MXU&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static方式可以在类初始化时就加载，当然，如果不想写成static，也可以自行加载</p></blockquote><p>那么，查询的时候，直接get就可以了，而且不需要对key值进行额外的判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String deviceName = deviceType2NameMap.get(type);</span><br></pre></td></tr></table></figure><p>当然，还有一种逻辑固定的if/else也很常见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;run&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doRun(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;fly&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doFly(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sleep&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doSleep(param);</span><br><span class="line">&#125; <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>这里分支后的执行过程换成了函数，不同的行为执行不同的函数<br>转换为<strong>表驱动</strong>方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假定上述的param类型为int</span></span><br><span class="line">Map&lt;String, Consumer&lt;Integer&gt;&gt; actionMappings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">initActionMap()&#123;</span><br><span class="line"><span class="comment">// 使用方法引用替换Lambda表达式</span></span><br><span class="line">    <span class="comment">// Test::doRun等价于param -&gt; doRun(param)</span></span><br><span class="line">actionMappings.put(<span class="string">&quot;run&quot;</span>, Test::doRun);</span><br><span class="line">actionMappings.put(<span class="string">&quot;fly&quot;</span>, Test::doFly);</span><br><span class="line">actionMappings.put(<span class="string">&quot;sleep&quot;</span>, Test::doSleep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doRun(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doFly(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doSleep(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionMappings.get(<span class="string">&quot;run&quot;</span>).accept(param);</span><br></pre></td></tr></table></figure><p>可能有人不清楚<strong>Consumer</strong>是个什么，为什么最后又执行了<strong>accept</strong>方法<br>这里简单说下</p><blockquote><ul><li>Consumer&lt;T&gt;是Java8以后提供的函数式接口</li><li>T：入参类型；没有出参</li><li>调用方法：void accept(T t);</li><li>因为没有出参，常用于打印、发送短信等<strong>消费动作</strong></li></ul></blockquote><p>由此可见，表驱动的优势</p><blockquote><ul><li>数据逻辑分离，保证在修改数据时，不会对逻辑产生影响。</li><li>单元测试时可以注入表格，只要数据可以转换成表，我们可以输入任意形式的数据。</li><li>逻辑固定写死在程序中，因为修改逻辑成本高，数据则是灵活变换的，因为修改数据成本低。</li><li>保证多人开发时代码的稳健性，简单的逻辑易于读懂易于维护，并且多人使用时，只用修改数据段即可，而数据本身不需要再测试。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

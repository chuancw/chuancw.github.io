<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PostgreSQL集群主备复制方式</title>
      <link href="/2021/11/16/PostgreSQL%E9%9B%86%E7%BE%A4%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/11/16/PostgreSQL%E9%9B%86%E7%BE%A4%E4%B8%BB%E5%A4%87%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="复制方式"><a href="#复制方式" class="headerlink" title="复制方式"></a><strong>复制方式</strong></h1><blockquote><p>一主一备是同步物理流复制</p><p><code>RO</code>是异步流复制</p></blockquote><p>当备机宕机后，如果此时主库有写操作，会写等待，此时管控会降为异步流复制模式，并重做备库</p><p>&emsp;</p><p>&emsp;</p><h1 id="设置synchronous-commit参数"><a href="#设置synchronous-commit参数" class="headerlink" title="设置synchronous_commit参数"></a><strong>设置<code>synchronous_commit</code>参数</strong></h1><p>这个参数用来设置事务提交返回客户端之前，一个事务是否需要等待 <code>WAL</code> 记录被写入磁盘。合法的值是<code>&#123;local,remote_write,remote_apply,on,off&#125;</code></p><ul><li><p><code>off</code>   级别最低</p><p>当数据库事务提交时不需要等待本地 <code>wal buffer</code> 写入 <code>wal</code> 日志，立刻向客户端返回成功</p></li></ul><ul><li><p><code>local</code></p><p>当事务提交时，写入本地磁盘即可</p></li><li><p><code>remote_write</code></p><p>表示流复制主库提交事务时，需等待备库接收主库发送的wal日志流并写入<strong>备节点操作系统缓存</strong>中，之后向客户端返回成功，这种情况下备库出现异常关闭时不会有已传送的wal日志丢失风险，但备机<code>OS</code>异常宕机就有已传送的<code>wal</code>丢失风险</p><p>备机只需写入缓存，不需要落盘</p></li></ul><ul><li><p><code>remote_apply</code>  级别最高</p><p>表示流复制主库提交事务时，需等待备库接收主库发送的wal流并写入wal文件，同时备库已经完成回放，之后才向客户端返回成功，简单的说<code>remote_apply</code> 表示本地<code>wal</code>已落盘，<strong>备库<code>wal</code>已落盘并且已经完成回放</strong>，这个设置保证了拥有两份持久化的<code>wal</code>，同时备库也已经完成了回放</p><p>备机要<code>wal</code>回放完</p></li><li><p><strong><code>on</code> (默认)</strong></p><p>1 为<code>on</code>且没有开启同步备库的时候,会当<code>wal</code>日志真正刷新到磁盘永久存储后才会返回客户端事务已提交成功,</p><p>2 当为<code>on</code>且开启了同步备库的时候(设置了<code>synchronous_standby_names</code>),必须要等事务日志刷新到本地磁盘,并且还要等远程<strong>备库也提交到磁盘</strong>才能返回客户端已经提交.</p><p>主备都要<code>wal</code>落盘</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现接口幂等性</title>
      <link href="/2021/10/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2021/10/17/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h2><p>什么是幂等性？一次和多次请求某一个资源，对资源本身所产生的的影响均与一次执行的影响相同。</p><p>幂等性是系统服务对外的一种承诺，承诺只要调用接口成功了，多次调用对系统的影响是<font color=orange>一致</font>的。</p><p>&emsp;</p><h2 id="幂等性与重复提交比较"><a href="#幂等性与重复提交比较" class="headerlink" title="幂等性与重复提交比较"></a>幂等性与重复提交比较</h2><p><strong>幂等性</strong> 更多使用的情况是第一次请求知道结果，但是由于网络抖动或连接超时等情况未进行正常返回，在这种情况下系统自动再次发起请求，其目的是确认第一次是否请求完成。</p><p><strong>重复提交</strong> 更多使用的情况是第一次请求成功或请求结果暂未返回的情况下，人为的进行多次操作。</p><p>&emsp;</p><h2 id="为什么需要保证接口的幂等性？"><a href="#为什么需要保证接口的幂等性？" class="headerlink" title="为什么需要保证接口的幂等性？"></a>为什么需要保证接口的幂等性？</h2><p>接口的幂等性非常重要，因为在实际的应用中，接口可能会被调用多次，例如在网络不稳定或者客户端重试的情况下。如果接口没有保证幂等性，那么就会导致数据或者业务逻辑出现不一致的情况。</p><p>例如，如果一个非幂等性的接口被调用两次，第一次调用时创建了一个资源，第二次调用时又创建了一个相同的资源，这样就会导致资源数量不一致。</p><p>&emsp;</p><h2 id="哪些场景需要保证幂等性"><a href="#哪些场景需要保证幂等性" class="headerlink" title="哪些场景需要保证幂等性"></a>哪些场景需要保证幂等性</h2><p><strong>前端重复提交表单</strong>：在填写一些表单数据的时候，用户点击提交按钮，但是由于网络波动导致服务端没有及时给用户返回提交成功的响应，致使用户认为没有成功提交而重复点击提交按钮，这样就会重复提交表单数据。</p><p>&emsp;</p><p><strong>超时重试机制</strong>：在分布式架构中，由于引入了网络通信导致一个请求除了成功和失败以外还多了一个未知的状态，也就是有可能这次请求在服务端执行成功了，由于网络故障等原因，客户端在一定时间内没有收到服务端的响应，于是客户端为了保证这次操作的成功会发起一个重试操作，导致同一个接口被重复调用了多次。</p><p>&emsp;</p><p><strong>MQ消息重复消费</strong>：正常情况下，消费者在消费消息的时候，消费完毕后会发送一个确认的信号（ACK）给消息队列，消息队列在收到确认信号（ACK）的时候就知道这条消息已经被成功消费了，于是就会把这条消息从消息队列中删除，但是可能由于网络波动等故障，这个确认的信号（ACK）没有传送到消息队列，导致消息队列会认为这条消息没有消费成功，于是消息队列会把这条消息发送给其他的消费者去消费，这样就导致消息被重复消费了。</p><p>&emsp;</p><h2 id="SQL-语句幂等性"><a href="#SQL-语句幂等性" class="headerlink" title="SQL 语句幂等性"></a>SQL 语句幂等性</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行多少次都不会对资源造成影响，查询具有天然的幂等性。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次状态都是一致的，这种场景是幂等操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> score <span class="operator">=</span> score<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>每次执行的结果都会发生变化，这种场景不是幂等操作。</p><p>根据具体场景看能否写成这样的 <font color=orange>SQL</font> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE `<span class="keyword">user</span>` <span class="keyword">SET</span> score <span class="operator">=</span> score<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> score <span class="operator">=</span> <span class="number">59</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次分数都是一致的，这种场景是幂等操作。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>` <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>无论执行成功多少次数据都是一致的，这种场景是幂等操作。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`name`, `status`, `score`) <span class="keyword">VALUES</span> (<span class="string">&#x27;tom&#x27;</span>, <span class="number">1</span>, <span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>每次执行的结果都会发生变化，这种场景不是幂等操作。</p><p>根据具体场景看能否为 <font color=orange>name</font> 创建一个唯一索引，或执行类型这样的 <font color=orange>SQL</font> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ... <span class="keyword">values</span> ... <span class="keyword">ON</span> DUPLICATE KEY UPDATE ...</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注意，要使用这条语句，前提条件是这个表必须有一个唯一索引或主键。</span><br></pre></td></tr></table></figure><p>&emsp;</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>以下是保证接口幂等性的几种常见方法。</p><h3 id="1-唯一标识符"><a href="#1-唯一标识符" class="headerlink" title="1. 唯一标识符"></a>1. 唯一标识符</h3><p>为了保证接口的幂等性，我们可以为每个请求生成一个唯一标识符。可以使用UUID或其他类似的方法生成这个标识符。这个标识符可以在服务器端存储，以确保同一请求只被处理一次。</p><p>在客户端发送请求时，我们需要将这个唯一标识符一起发送到服务器端。服务器端接收到请求后，可以检查这个唯一标识符是否已经处理过。如果已经处理过，就不再处理这个请求，而是直接返回结果。</p><p>&emsp;</p><h3 id="2-数据库唯一索引"><a href="#2-数据库唯一索引" class="headerlink" title="2. 数据库唯一索引"></a>2. 数据库唯一索引</h3><p><strong>适用于插入操作</strong>。</p><p>在设计表的时候我们可以规定一些在业务上唯一的字段（比如：身份证号、订单号），为这些字段建立一个唯一索引。在做插入操作的时候，第一次请求的数据可以插入成功。但后面的相同请求，插入数据时会报 <code>Duplicate entry &#39;xxx&#39; for key &#39;xxxxxxx&#39;</code> 异常，表示唯一索引有冲突。</p><blockquote><p>缺点：</p><p>效率不高，只支持插入操作，并且高并发下数据库压力比较大</p></blockquote><p>&emsp;</p><h3 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3. 乐观锁"></a>3. 乐观锁</h3><p>乐观锁是一种并发控制的方法。在Web开发中，乐观锁可以用来保证接口的幂等性。具体实现方法如下：</p><ul><li>当客户端发送请求时，服务器端首先读取当前资源的版本号。</li><li>服务器端根据客户端请求更新资源，并生成新的版本号。</li><li>服务器端将新的版本号返回给客户端。</li></ul><p>如果客户端重复发送请求，服务器端会检查请求中的版本号是否与当前资源的版本号相同。如果相同，说明这个请求已经被处理过，服务器端不会再次处理请求，直接返回结果。</p><p>&emsp;</p><h3 id="4-Token"><a href="#4-Token" class="headerlink" title="4. Token"></a>4. Token</h3><p>幂等性Token是一种用来保证接口幂等性的标识符。当客户端发送请求时，服务器端会为这个请求生成一个幂等性Token。这个Token可以在服务器端存储，以确保同一请求只被处理一次。</p><p>在客户端发送请求时，需要将这个幂等性Token一起发送到服务器端。服务器端接收到请求时，会检查这个Token是否已经处理过。如果已经处理过，就不再处理这个请求，而是直接返回结果。</p><p>&emsp;</p><h3 id="5-Redis-Token"><a href="#5-Redis-Token" class="headerlink" title="5. Redis+Token"></a>5. Redis+Token</h3><p><img src="https://user-images.githubusercontent.com/19164993/219409369-46340421-09ca-494b-b688-1c5eb9bdf39f.png" alt="redis-token"></p><p>&emsp;</p><h3 id="6-状态机"><a href="#6-状态机" class="headerlink" title="6. 状态机"></a>6. 状态机</h3><p>有的业务表是有状态的，可以根据状态字段保证接口的幂等性。</p><p>比如在云数据库管控系统中，数据库实例的状态有(初始化、运行中、变配中)等状态，当一个请求发起实例变配时，会首先去查询表中该实例的状态，只有在运行中状态的实例才可以执行成功，并把状态改为变配中，此时如果有重复的请求过来，查询到状态是变配中，直接返回，不允许操作。</p><p>&emsp;</p><h3 id="7-防重表"><a href="#7-防重表" class="headerlink" title="7. 防重表"></a>7. 防重表</h3><p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。</p><p>针对这种情况，可以通过建防重表来解决问题。</p><p>该表可以只包含两个字段：id 和 唯一索引，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：gouri_123</p>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈国产数据库在金融界的应用-概念篇</title>
      <link href="/2021/10/10/%E6%B5%85%E8%B0%88%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E9%87%91%E8%9E%8D%E7%95%8C%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%80)/"/>
      <url>/2021/10/10/%E6%B5%85%E8%B0%88%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8%E9%87%91%E8%9E%8D%E7%95%8C%E7%9A%84%E5%BA%94%E7%94%A8(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>移动互联网发展至今，移动支付占据了90%以上的交易量，传统的金融IT架构面临着海量的高并发响应、处理速度以及安全性的挑战。<br>金融行业的数据库市场，尤其是银行的核心交易系统，一直是 <font color=orange>Oracle、DB2</font> 这类美国传统商业数据库的天下，从银行系统的角度来看，所承担的业务量将是海量式的增长，同时也不可避免带来金融行业数据安全、业务安全方面的风险，传统数据库显然不满足需求了。</p><h2 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h2><p>随着国家有关部门近年来陆续出台相关政策指导文件，推动探索安全可控的金融科技产品，加强银行业信息安全建设，由新型分布式数据库替代传统集中式架构，成为金融级数据库市场的主流趋势。<br>央行19年发布《金融科技(FinTech)发展规划(2019-2021年)》也强调，加强分布式数据库研发应用，为分布式数据库在金融领域的全面应用探明路径。国内众多金融政企机构纷纷开始探索改造原有IT系统，对国产化数据库的需求日益强烈。</p><h2 id="云时代"><a href="#云时代" class="headerlink" title="云时代"></a>云时代</h2><p>在数字经济时代的今天，各行各业都在加速<mark class="hl-label red">上云</mark> ，金融业也行驶在数字化转型的浪潮中。在其背后，数据库承载着金融机构的核心数据，是金融科技业务创新的基础和底座，阿里云、腾讯云、华为云三家中国云计算厂商巨头纷纷推出了自己的国产云数据库产品。</p><h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><h3 id="1、TBase"><a href="#1、TBase" class="headerlink" title="1、TBase"></a>1、TBase</h3><p>分布式HTAP数据库 <font color=orange>TBase（TencentDB for TBase）</font>是腾讯自主研发的分布式数据库系统，集高扩展性、高SQL兼容度、完整的分布式事务支持、多级容灾能力以及多维度资源隔离等能力于一身。TBase 强大的安全和容灾能力，已经成功应用在金融、政府、电信、医疗等行业的核心业务系统。同时，TBase 采用无共享的集群架构，为用户提供容灾、备份、恢复、监控、安全、审计等全套解决方案，适用于GB～PB级的海量 HTAP 场景</p><mark class="hl-label red">TBase</mark> 已经覆盖多个行业的标杆用户，其中对内支持了微信广告、微信支付、腾讯地图以及腾讯游戏等海量数据业务，一笔交易毫秒内即可完成，支撑了微信支付50倍的交易增长<p><img src="https://user-images.githubusercontent.com/37777293/136667363-b81ed98b-a31c-43ba-b187-17d99b941a41.png" alt="TBase"></p><h3 id="2、TDSQL"><a href="#2、TDSQL" class="headerlink" title="2、TDSQL"></a>2、TDSQL</h3><p>分布式数据库<font color=orange>TDSQL（Tencent Distributed SQL）</font>是腾讯打造的一款分布式数据库产品，具备强一致高可用、全球部署架构、分布式水平扩展、高性能、企业级安全等特性，同时提供智能 DBA、自动化运营、监控告警等配套设施，为客户提供完整的分布式数据库解决方案。<br>目前 TDSQL 已经为超过<mark class="hl-label red">600+</mark> 的政企和金融机构提供数据库的公有云及私有云服务，客户覆盖银行、保险、证券、互联网金融、计费、第三方支付、物联网、互联网+、政务等领域。TDSQL 亦凭借其高质量的产品及服务，获得了多项国际和国家认证，得到了客户及行业的一致认可<br><img src="https://user-images.githubusercontent.com/37777293/136667439-a07a62f6-f1c2-4611-9796-3d957a937f8f.png" alt="TDSQL"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 金融 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何减少代码里的if/else</title>
      <link href="/2021/10/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/"/>
      <url>/2021/10/05/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%BB%A3%E7%A0%81%E9%87%8C%E7%9A%84if/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>if/else是高级编程语言中最基础的功能，虽然 if/else 是必须的，但滥用 if/else，特别是各种大量的if/else嵌套，会对代码的可读性、可维护性造成很大伤害，对于阅读代码的人来说就是一场灾难。</p><p>本系列博客的目的不是消除if/else,而是如何“写好”if/else</p><h2 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h2><p>根据if/else的使用方式和场景，大概有如下解决方法</p><blockquote><ul><li>多态</li><li>表驱动</li><li>职责链模式</li><li>卫语句</li><li>Optional</li><li>调整判断逻辑，抽取方法，逻辑优化</li></ul></blockquote><p>本篇博客我介绍的是<strong>表驱动</strong>，后续博客会介绍其他案例<br>首先来看下最简单的if…else if…场景，也是经常可以在代码中看到的案例</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>有如下业务代码demo，根据type值，判断然后返回设备的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑表达模式固定的 if…else</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着时间的积累和项目的迭代，可能会增加越来越多的类型，那么后人会继续增加if/else分支，代码中存在的分支判断就会越来越多，当分支数量实在是多的难以维护的时候，我们就要考虑下，有办法能让这些代码变得更优雅吗？</p><p>可能有的人会说用switch/case来重构代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDeviceName</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;OLT&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ONU&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MXU&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，换成switch/case也是一样，后续也要维护大量case分支，特别是当同样的逻辑判断出现在多个地方的时候，代码的可读性和维护难易程度将变得非常的糟糕。每次修改时，你必须找到所有有逻辑分支的地方，并修改它们</p><p>下面，我就来介绍一种针对这种if/else判断的最简单的重构方式，那就是使用<strong>表驱动</strong></p><h2 id="4-表驱动重构代码"><a href="#4-表驱动重构代码" class="headerlink" title="4. 表驱动重构代码"></a>4. 表驱动重构代码</h2><p>表驱动方法（Table-Driven Methods），《代码大全》对此进行了详细地讲解。</p><blockquote><p>表驱动法是一种编程模式（Scheme），从表里面查找信息而不使用逻辑语句（if 和case） 它的好处是消除代码里面到处出现的if、else、switch语句，让凌乱代码变得简明和清晰。<br>对简单情况而言，表驱动方法可能仅仅使逻辑语句更容易和直白，但随着逻辑的越来越复杂，表驱动法就愈发有吸引力。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;Integer, String&gt; deviceType2NameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    deviceType2NameMap.put(<span class="number">1</span>, <span class="string">&quot;ONT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">2</span>, <span class="string">&quot;OLT&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">3</span>, <span class="string">&quot;ONU&quot;</span>);</span><br><span class="line">    deviceType2NameMap.put(<span class="number">4</span>, <span class="string">&quot;MXU&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>static方式可以在类初始化时就加载，当然，如果不想写成static，也可以自行加载</p></blockquote><p>那么，查询的时候，直接get就可以了，而且不需要对key值进行额外的判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String deviceName = deviceType2NameMap.get(type);</span><br></pre></td></tr></table></figure><p>当然，还有一种逻辑固定的if/else也很常见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;run&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doRun(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;fly&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doFly(param);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sleep&quot;</span>.equals(action)) &#123;</span><br><span class="line">   doSleep(param);</span><br><span class="line">&#125; <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><p>这里分支后的执行过程换成了函数，不同的行为执行不同的函数<br>转换为<strong>表驱动</strong>方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假定上述的param类型为int</span></span><br><span class="line">Map&lt;String, Consumer&lt;Integer&gt;&gt; actionMappings = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">initActionMap()&#123;</span><br><span class="line"><span class="comment">// 使用方法引用替换Lambda表达式</span></span><br><span class="line">    <span class="comment">// Test::doRun等价于param -&gt; doRun(param)</span></span><br><span class="line">actionMappings.put(<span class="string">&quot;run&quot;</span>, Test::doRun);</span><br><span class="line">actionMappings.put(<span class="string">&quot;fly&quot;</span>, Test::doFly);</span><br><span class="line">actionMappings.put(<span class="string">&quot;sleep&quot;</span>, Test::doSleep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doRun(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doFly(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line">doSleep(<span class="keyword">int</span> param) &#123;...&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionMappings.get(<span class="string">&quot;run&quot;</span>).accept(param);</span><br></pre></td></tr></table></figure><p>可能有人不清楚<strong>Consumer</strong>是个什么，为什么最后又执行了<strong>accept</strong>方法<br>这里简单说下</p><blockquote><ul><li>Consumer&lt;T&gt;是Java8以后提供的函数式接口</li><li>T：入参类型；没有出参</li><li>调用方法：void accept(T t);</li><li>因为没有出参，常用于打印、发送短信等<strong>消费动作</strong></li></ul></blockquote><p>由此可见，表驱动的优势</p><blockquote><ul><li>数据逻辑分离，保证在修改数据时，不会对逻辑产生影响。</li><li>单元测试时可以注入表格，只要数据可以转换成表，我们可以输入任意形式的数据。</li><li>逻辑固定写死在程序中，因为修改逻辑成本高，数据则是灵活变换的，因为修改数据成本低。</li><li>保证多人开发时代码的稳健性，简单的逻辑易于读懂易于维护，并且多人使用时，只用修改数据段即可，而数据本身不需要再测试。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if </tag>
            
            <tag> 优化 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL是如何实现MVCC的</title>
      <link href="/2021/07/16/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVCC%E7%9A%84/"/>
      <url>/2021/07/16/MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0MVCC%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于 (隐藏字段 + <code>undolog</code> + <code>readView</code>)来实现<code>MVCC</code>的</p><ul><li><p><code>undolog</code> ：</p><p>修改数据时，将该记录写入到版本链中，<code>undolog</code>， 每次放在头部。</p><p>&emsp;</p></li><li><p>行隐藏字段：</p><p> <code>db_trx_id</code>：事务ID，全局唯一</p><p> <code>roll_pointer</code> 版本链指针</p></li></ul><p><img src="https://user-images.githubusercontent.com/19164993/219787502-1fdd650c-96c2-4128-b882-0e0652743133.png" alt="mvcc"></p><p><code>ReadView</code>中的统计值：</p><ul><li><code>m_ids</code>  当前活跃的事务集合（所有未提交的事务）</li><li><code>min_trx_id</code>   <code>m_ids</code>中最小的。即最小的活跃事务ID</li><li><code>max_trx_id</code> 版本链头的事务+1。<code>max_trx_id</code>并不是<code>m_ids</code>中的最大值，事务ID是递增分配的。比方说现在有<code>id</code>为1，2，3这三个事务，之后<code>id</code>为3的事务提交了。那么一个新的读事务在生成<code>ReadView</code>时，<code>m_ids</code>就包括1和2，<code>min_trx_id</code>的值就是1，<code>max_trx_id</code>的值就是4</li><li><code>creator_trx_id</code> 当前创建这个视图的事务ID</li></ul><p>根据上图，当前事务ID为201时，统计值如下：</p><p><code>m_ids</code> = [90,100, 200]</p><p><code>min_tx_id</code> = 90</p><p><code>max_tx_id</code> = 200 + 1 = 201</p><p><code>creator_trx_id</code> = 201</p><p>&emsp;</p><h2 id="判断规则"><a href="#判断规则" class="headerlink" title="判断规则"></a>判断规则</h2><p>从<code>undolog</code>链表头部开始遍历</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (该记录trx_id == 当前自己的事务id) &#123;</span><br><span class="line">     那么就是当前事务自己修改的，当然可以访问  <span class="keyword">true</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(该记录trx_id &lt; min_tx_id) &#123;</span><br><span class="line">     那么该记录的事务在自己生成readView前就已经提交了，可以被当前事务访问  <span class="keyword">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(该记录trx_id &gt;= max_tx_id) &#123;</span><br><span class="line">      那么该事务是在readview生成之后才开启，不能被当前事务访问 <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(min_tx_id &lt; 该记录trx_id &lt; max_tx_id) &#123;</span><br><span class="line">        <span class="keyword">if</span>(该记录trx_id 在 m_ids中）&#123;</span><br><span class="line">          说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问  <span class="keyword">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          说明创建ReadView时生成该版本的事务已经被提交，可以被当前事务访问  <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL主从搭建</title>
      <link href="/2021/07/14/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/07/14/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Master配置"><a href="#一、Master配置" class="headerlink" title="一、Master配置"></a>一、Master配置</h1><p>1、修改<code>postgresql.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span>   <span class="comment">#监听的IP地址</span></span><br><span class="line">wal_level = hot_standby  <span class="comment">#启用热备模式</span></span><br><span class="line">synchronous_commit = on  <span class="comment">#开启同步复制</span></span><br><span class="line">max_wal_senders = 2      <span class="comment">#同步最大的进程数量</span></span><br><span class="line">wal_sender_timeout = 60s <span class="comment">#流复制主机发送数据的超时时间</span></span><br><span class="line">max_connections = 100    <span class="comment">#最大连接数，从库的max_connections必须要大于主库的</span></span><br></pre></td></tr></table></figure><p>2、创建同步账号，用于流复制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user replica with password <span class="string">&#x27;123456&#x27;</span> replication;</span><br></pre></td></tr></table></figure><p>3、修改<code>pg_hba.conf</code>，允许从库地址通信</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host replication replica 主机ip/32 md5   <span class="comment">#在master上可以执行pg_basebackup</span></span><br><span class="line">host replication replica 备机ip/32 md5   <span class="comment">#slave可以和master正常通信</span></span><br></pre></td></tr></table></figure><p>4、重新加载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl -D /data/pg_data/data reload</span><br></pre></td></tr></table></figure><p>&emsp;</p><p>&emsp;</p><h1 id="二、Slave配置"><a href="#二、Slave配置" class="headerlink" title="二、Slave配置"></a>二、Slave配置</h1><p>1、在<code>slave</code>上运行<code>pg_basebackup</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_basebackup -D /data/pg_data/data -h &lt;主节点IP&gt; -p 5432 -U replica -X stream -P</span><br></pre></td></tr></table></figure><p>2、创建<code>recovery.conf</code>文件，修改如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">standby_mode = on     <span class="comment">#声明此节点为从库</span></span><br><span class="line">primary_conninfo = <span class="string">&#x27;host=&lt;主节点IP&gt; port=5432 user=replica password=123456&#x27;</span> <span class="comment">#对应主库的连接信息</span></span><br><span class="line">recovery_target_timeline = <span class="string">&#x27;latest&#x27;</span> <span class="comment">#流复制同步到最新的数据</span></span><br></pre></td></tr></table></figure><p>3、修改<code>postgresql.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max_connections = 1000             <span class="comment"># 最大连接数，从节点需设置比主节点大</span></span><br><span class="line">hot_standby = on                   <span class="comment"># 开启热备</span></span><br><span class="line">max_standby_streaming_delay = 30s  <span class="comment"># 数据流备份的最大延迟时间</span></span><br><span class="line">wal_receiver_status_interval = 1s  <span class="comment"># 从节点向主节点报告自身状态的最长间隔时间</span></span><br><span class="line">hot_standby_feedback = on          <span class="comment"># 如果有错误的数据复制向主进行反馈</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Stolon快速构建PostgreSQL集群</title>
      <link href="/2021/06/21/%E5%9F%BA%E4%BA%8EStolon%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAPostgreSQL%E9%9B%86%E7%BE%A4/"/>
      <url>/2021/06/21/%E5%9F%BA%E4%BA%8EStolon%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAPostgreSQL%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><p>准备3台机器模拟PG HA架构，其中etcd和proxy为单节点，便于测试环境搭建</p><table><thead><tr><th>组件</th><th>ip</th><th>port</th><th>角色</th></tr></thead><tbody><tr><td>etcd</td><td>192.168.5.220</td><td>2379</td><td></td></tr><tr><td>postgres0</td><td>192.168.0.200</td><td>5432</td><td>master</td></tr><tr><td>postgres1</td><td>192.168.0.220</td><td>5432</td><td></td></tr><tr><td>proxy</td><td>192.168.5.220</td><td>25432</td><td></td></tr></tbody></table><p>&emsp;</p><h2 id="初始化步骤"><a href="#初始化步骤" class="headerlink" title="初始化步骤"></a>初始化步骤</h2><p>1、初始化集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stolonctl --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints= http://192.168.5.220:2379  init</span><br></pre></td></tr></table></figure><p>2、启动一个sentinel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stolon-sentinel --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints=http://192.168.5.220:2379</span><br><span class="line"></span><br><span class="line">&gt;&gt; sentinel id id=66613766</span><br><span class="line">&gt;&gt; Trying to acquire sentinels leadership</span><br><span class="line">&gt;&gt; sentinel leadership acquired</span><br></pre></td></tr></table></figure><p>3、启动一个keeper (主 postgres0) (第一个启动的是主)</p><p>这将启动一个uid为postgres0的keeper进程，监听在192.168.5.200:5432 上，在data/postgres0/postgres/ 目录初始化出一个PG实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">stolon-keeper --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints= http://192.168.5.220:2379 --uid postgres0 --data-dir data/postgres0 --pg-su-password=supassword --pg-repl-username=repluser --pg-repl-password=replpassword --pg-listen-address=192.168.5.200</span><br><span class="line"></span><br><span class="line">&gt;&gt; exclusive lock on data dir taken</span><br><span class="line">&gt;&gt; keeper uid uid=postgres0</span><br><span class="line">&gt;&gt; stopping database</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; current db UID different than cluster data db UID db= cdDB=2a87ea79</span><br><span class="line">&gt;&gt; initializing the database cluster</span><br><span class="line">&gt;&gt; cannot get configured pg parameters error=dial tcp 127.0.0.1:5432: getsockopt: connection refused</span><br><span class="line">&gt;&gt; starting database</span><br><span class="line">&gt;&gt; error getting pg state error=pq: password authentication failed <span class="keyword">for</span> user <span class="string">&quot;repluser&quot;</span></span><br><span class="line">&gt;&gt; setting roles</span><br><span class="line">&gt;&gt; setting superuser password</span><br><span class="line">&gt;&gt; superuser password <span class="built_in">set</span></span><br><span class="line">&gt;&gt; creating replication role</span><br><span class="line">&gt;&gt; replication role created role=repluser</span><br><span class="line">&gt;&gt; stopping database</span><br><span class="line">&gt;&gt; our db requested role is master</span><br><span class="line">&gt;&gt; starting database</span><br><span class="line">&gt;&gt; already master</span><br><span class="line">&gt;&gt; postgres parameters changed, reloading postgres instance</span><br><span class="line">&gt;&gt; reloading database configuration</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>此时setinel将选举该实例为master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; trying to find initial master</span><br><span class="line">&gt;&gt; initializing cluster keeper=postgres0</span><br><span class="line">&gt;&gt; received db state <span class="keyword">for</span> unexpected db uid receivedDB= db=2a87ea79</span><br><span class="line">&gt;&gt; waiting <span class="keyword">for</span> db db=2a87ea79 keeper=postgres0</span><br><span class="line">&gt;&gt; waiting <span class="keyword">for</span> db db=2a87ea79 keeper=postgres0</span><br><span class="line">&gt;&gt; waiting <span class="keyword">for</span> db db=2a87ea79 keeper=postgres0</span><br><span class="line">&gt;&gt; db initialized db=2a87ea79 keeper=postgres0</span><br></pre></td></tr></table></figure><p>4、再启动一个keeper (备 postgres1)</p><p>这个实例将和master建立复制关系，成为备机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">stolon-keeper --cluster-name stolon-cluster --store-backend=etcdv3 --store-endpoints= http://192.168.5.220:2379 --uid postgres1 --data-dir data/postgres1 --pg-su-password=supassword --pg-repl-username=repluser --pg-repl-password=replpassword --pg-listen-address=192.168.5.220</span><br><span class="line"></span><br><span class="line">&gt;&gt; exclusive lock on data dir taken</span><br><span class="line">&gt;&gt; keeper uid uid=postgres1</span><br><span class="line">&gt;&gt; stopping database</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; our keeper data is not available, waiting <span class="keyword">for</span> it to appear</span><br><span class="line">&gt;&gt; current db UID different than cluster data db UID db= cdDB=63343433</span><br><span class="line">&gt;&gt; database cluster not initialized</span><br><span class="line">&gt;&gt; our db requested role is standby followedDB=2a87ea79</span><br><span class="line">&gt;&gt; running pg_basebackup</span><br><span class="line">&gt;&gt; sync succeeded</span><br><span class="line">&gt;&gt; starting database</span><br><span class="line">&gt;&gt; postgres parameters changed, reloading postgres instance</span><br><span class="line">&gt;&gt; reloading database configuration</span><br><span class="line">&gt;&gt; our db requested role is standby followedDB=2a87ea79</span><br><span class="line">&gt;&gt; already standby</span><br></pre></td></tr></table></figure><p>&emsp;</p><h2 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h2><p><strong>keeper</strong></p><p>Keeper 等于是在PG上层包装了一层，内嵌了很多PG主从初始化、切换以及一些Failover处理的逻辑。而Keeper做这些操作的依据就是Sentinel生成的Cluster Data（存储在Etcd），Keeper会一直轮询集群状态。</p><p>&emsp;</p><p><strong>sentinel</strong></p><p>Sentinel用来选主、以及监控所有PG实例的健康状态，会在Master不可用的时候，选举出最合适的Slave来设置成新的Master（通过PG Xlog来判断）</p><p>&emsp;</p><p><strong>Proxy</strong></p><p>Sentinel + Proxy 有点像Redis的哨兵。Proxy 是客户端的流量入口，会将所有的流量转发到Master，如果发生了主备切换，Proxy也会关闭旧的Master的连接。至于Proxy是如何判断Master节点，也是依赖Sentinel生成的Cluster Data。Proxy 实现上依赖的是一个自行开发的网络库，支持代理转发流量，同时支持对Socket FD设置TCP Keepalived参数，通过Goroutine而不是线程来处理请求，可以极大的减少资源开销。综上，可以看到Sentinel + Proxy组合起来承担了类似Redis哨兵的功能</p><p>&emsp;</p><h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><p>1、stolonctl init      集群初始化</p><p>将集群的元数据信息、ClusterSpec等存放在etcd上</p><p>&emsp;</p><p>2、 stolon-sentinel   启动1个sentinel  </p><p> 1）最早创建的sentinel成为leader。借助etcd的leader选举机制</p><p> 2） 把sentinel的信息存放在etcd上</p><p> 3）从etcd拉取keeper的信息</p><p> 4）如果当前sentinel不是leader，就直接返回</p><p> 5） 监控keeper，（健康检查、如果发现当前集群还没有master，就将发现的第一个keeper设置为master</p><p>&emsp;</p><p>3、stolon-keeper  启动1个keeper</p><p> 1）initdb                    初始化数据库</p><p> 2）postgres -D /dir   启动数据库</p><p> 3）直到出现postmaster.pid文件，检查下pid，启动成功</p><p>&emsp;</p><p>4、再次创建1个sentinel和keeper</p><p>keeper将备机的复制信息写入recovery.conf文件，运行 pg_basebackup 建立同步</p><p>该sentinel不工作</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在最前面的话</title>
      <link href="/2020/10/05/hello-world/"/>
      <url>/2020/10/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome! 这是我的第一篇博客</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>及时总结和分享<br>包括但不限于以下内容：</p><blockquote><ul><li>技术总结</li><li>行业思考</li><li>刷题笔记</li><li>职场经验</li></ul></blockquote><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>后续会将本地的笔记和记录整理成博客文章发布</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
